// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: openrtb-v2_6.proto

#ifndef PROTOBUF_openrtb_2dv2_5f6_2eproto__INCLUDED
#define PROTOBUF_openrtb_2dv2_5f6_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

class BidRequest;
class Scenario;
class Imp;
class Banner;
class Site;
class App;
class Publisher;
class Device;
class Geo;
class User;
class BidResponse;
class SeatBid;
class Bid;

enum ContentCategory {
  CAT_801 = 801,
  CAT_80101 = 80101,
  CAT_80102 = 80102,
  CAT_80103 = 80103,
  CAT_80106 = 80106,
  CAT_80107 = 80107,
  CAT_80108 = 80108,
  CAT_80110 = 80110,
  CAT_802 = 802,
  CAT_80201 = 80201,
  CAT_80203 = 80203,
  CAT_80205 = 80205,
  CAT_80206 = 80206,
  CAT_80207 = 80207,
  CAT_80210 = 80210,
  CAT_80212 = 80212,
  CAT_80213 = 80213,
  CAT_80214 = 80214,
  CAT_80215 = 80215,
  CAT_80216 = 80216,
  CAT_803 = 803,
  CAT_80301 = 80301,
  CAT_80302 = 80302,
  CAT_80303 = 80303,
  CAT_804 = 804,
  CAT_80401 = 80401,
  CAT_80402 = 80402,
  CAT_80403 = 80403,
  CAT_80404 = 80404,
  CAT_80405 = 80405,
  CAT_805 = 805,
  CAT_80501 = 80501,
  CAT_80502 = 80502,
  CAT_80503 = 80503,
  CAT_80504 = 80504,
  CAT_80505 = 80505,
  CAT_80506 = 80506,
  CAT_80507 = 80507,
  CAT_80509 = 80509,
  CAT_806 = 806,
  CAT_80601 = 80601,
  CAT_8060101 = 8060101,
  CAT_8060102 = 8060102,
  CAT_8060103 = 8060103,
  CAT_8060104 = 8060104,
  CAT_8060105 = 8060105,
  CAT_8060106 = 8060106,
  CAT_8060107 = 8060107,
  CAT_8060108 = 8060108,
  CAT_8060109 = 8060109,
  CAT_80602 = 80602,
  CAT_80603 = 80603,
  CAT_80604 = 80604,
  CAT_80605 = 80605,
  CAT_80606 = 80606,
  CAT_80607 = 80607,
  CAT_80608 = 80608,
  CAT_80609 = 80609,
  CAT_808 = 808,
  CAT_80801 = 80801,
  CAT_80803 = 80803,
  CAT_80805 = 80805,
  CAT_80806 = 80806,
  CAT_80808 = 80808,
  CAT_80809 = 80809,
  CAT_809 = 809,
  CAT_80901 = 80901,
  CAT_80902 = 80902,
  CAT_810 = 810,
  CAT_81001 = 81001,
  CAT_81002 = 81002,
  CAT_81003 = 81003,
  CAT_81005 = 81005,
  CAT_81007 = 81007,
  CAT_81008 = 81008,
  CAT_81009 = 81009,
  CAT_811 = 811,
  CAT_81101 = 81101,
  CAT_81102 = 81102,
  CAT_81103 = 81103,
  CAT_81105 = 81105,
  CAT_812 = 812,
  CAT_81201 = 81201,
  CAT_81202 = 81202,
  CAT_81203 = 81203,
  CAT_81204 = 81204,
  CAT_81206 = 81206,
  CAT_81207 = 81207,
  CAT_81208 = 81208,
  CAT_81209 = 81209,
  CAT_81210 = 81210,
  CAT_81211 = 81211,
  CAT_81212 = 81212,
  CAT_81213 = 81213,
  CAT_81214 = 81214,
  CAT_81215 = 81215,
  CAT_81216 = 81216,
  CAT_81217 = 81217,
  CAT_813 = 813,
  CAT_81301 = 81301,
  CAT_81302 = 81302,
  CAT_81303 = 81303,
  CAT_81304 = 81304,
  CAT_81305 = 81305,
  CAT_81306 = 81306,
  CAT_81307 = 81307,
  CAT_81309 = 81309,
  CAT_814 = 814,
  CAT_81401 = 81401,
  CAT_81402 = 81402,
  CAT_81403 = 81403,
  CAT_81405 = 81405,
  CAT_815 = 815,
  CAT_81501 = 81501,
  CAT_81502 = 81502,
  CAT_81503 = 81503,
  CAT_81504 = 81504,
  CAT_816 = 816,
  CAT_81601 = 81601,
  CAT_81602 = 81602,
  CAT_81603 = 81603,
  CAT_81604 = 81604,
  CAT_81605 = 81605,
  CAT_81606 = 81606,
  CAT_81607 = 81607,
  CAT_81608 = 81608,
  CAT_81609 = 81609,
  CAT_81610 = 81610,
  CAT_817 = 817,
  CAT_81701 = 81701,
  CAT_81702 = 81702,
  CAT_81703 = 81703,
  CAT_81704 = 81704,
  CAT_81705 = 81705,
  CAT_81706 = 81706,
  CAT_81707 = 81707,
  CAT_81709 = 81709,
  CAT_81710 = 81710,
  CAT_81711 = 81711,
  CAT_81712 = 81712,
  CAT_81713 = 81713,
  CAT_81715 = 81715,
  CAT_81716 = 81716,
  CAT_818 = 818,
  CAT_81804 = 81804,
  CAT_81805 = 81805,
  CAT_81816 = 81816,
  CAT_81817 = 81817,
  CAT_81822 = 81822,
  CAT_81823 = 81823,
  CAT_819 = 819,
  CAT_81901 = 81901,
  CAT_81902 = 81902,
  CAT_81903 = 81903,
  CAT_820 = 820,
  CAT_82001 = 82001,
  CAT_82002 = 82002,
  CAT_82003 = 82003,
  CAT_82005 = 82005,
  CAT_82006 = 82006,
  CAT_82008 = 82008,
  CAT_82010 = 82010,
  CAT_822 = 822,
  CAT_82201 = 82201,
  CAT_82202 = 82202,
  CAT_82204 = 82204,
  CAT_82207 = 82207,
  CAT_82208 = 82208,
  CAT_823 = 823,
  CAT_82301 = 82301,
  CAT_82302 = 82302,
  CAT_82303 = 82303,
  CAT_82304 = 82304,
  CAT_82305 = 82305,
  CAT_82306 = 82306,
  CAT_82308 = 82308,
  CAT_824 = 824,
  CAT_825 = 825,
  CAT_82501 = 82501,
  CAT_82502 = 82502,
  CAT_82503 = 82503,
  CAT_82504 = 82504,
  CAT_82505 = 82505,
  CAT_82506 = 82506,
  CAT_82507 = 82507
};
bool ContentCategory_IsValid(int value);
const ContentCategory ContentCategory_MIN = CAT_801;
const ContentCategory ContentCategory_MAX = CAT_8060109;
const int ContentCategory_ARRAYSIZE = ContentCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContentCategory_descriptor();
inline const ::std::string& ContentCategory_Name(ContentCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContentCategory_descriptor(), value);
}
inline bool ContentCategory_Parse(
    const ::std::string& name, ContentCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContentCategory>(
    ContentCategory_descriptor(), name, value);
}
enum AdType {
  TEXT = 1,
  IMAGE = 2,
  JS = 3,
  IFRAME = 4
};
bool AdType_IsValid(int value);
const AdType AdType_MIN = TEXT;
const AdType AdType_MAX = IFRAME;
const int AdType_ARRAYSIZE = AdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdType_descriptor();
inline const ::std::string& AdType_Name(AdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdType_descriptor(), value);
}
inline bool AdType_Parse(
    const ::std::string& name, AdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdType>(
    AdType_descriptor(), name, value);
}
enum CreativeAttribute {
  ATTR_706 = 706,
  ATTR_70601 = 70601,
  ATTR_70602 = 70602,
  ATTR_70603 = 70603,
  ATTR_70699 = 70699,
  ATTR_711 = 711,
  ATTR_71101 = 71101,
  ATTR_71102 = 71102,
  ATTR_71103 = 71103,
  ATTR_71104 = 71104,
  ATTR_71105 = 71105,
  ATTR_71106 = 71106,
  ATTR_71107 = 71107,
  ATTR_71108 = 71108,
  ATTR_71109 = 71109,
  ATTR_71110 = 71110,
  ATTR_71111 = 71111,
  ATTR_71112 = 71112,
  ATTR_71113 = 71113,
  ATTR_71114 = 71114,
  ATTR_71115 = 71115,
  ATTR_71116 = 71116,
  ATTR_71117 = 71117,
  ATTR_71118 = 71118,
  ATTR_71119 = 71119,
  ATTR_71120 = 71120,
  ATTR_71121 = 71121,
  ATTR_71199 = 71199,
  ATTR_720 = 720,
  ATTR_72001 = 72001,
  ATTR_72002 = 72002,
  ATTR_72003 = 72003,
  ATTR_72005 = 72005,
  ATTR_72006 = 72006,
  ATTR_72007 = 72007,
  ATTR_72008 = 72008,
  ATTR_72099 = 72099,
  ATTR_722 = 722,
  ATTR_72201 = 72201,
  ATTR_72202 = 72202,
  ATTR_72203 = 72203,
  ATTR_72204 = 72204,
  ATTR_72205 = 72205,
  ATTR_72206 = 72206,
  ATTR_72207 = 72207,
  ATTR_72208 = 72208,
  ATTR_72209 = 72209,
  ATTR_72210 = 72210,
  ATTR_72211 = 72211,
  ATTR_72212 = 72212,
  ATTR_72299 = 72299,
  ATTR_701 = 701,
  ATTR_70101 = 70101,
  ATTR_70102 = 70102,
  ATTR_70103 = 70103,
  ATTR_70104 = 70104,
  ATTR_70105 = 70105,
  ATTR_70106 = 70106,
  ATTR_70107 = 70107,
  ATTR_70108 = 70108,
  ATTR_70109 = 70109,
  ATTR_70110 = 70110,
  ATTR_70111 = 70111,
  ATTR_70199 = 70199,
  ATTR_719 = 719,
  ATTR_71901 = 71901,
  ATTR_71902 = 71902,
  ATTR_71903 = 71903,
  ATTR_71904 = 71904,
  ATTR_71905 = 71905,
  ATTR_71906 = 71906,
  ATTR_71907 = 71907,
  ATTR_71908 = 71908,
  ATTR_71909 = 71909,
  ATTR_71910 = 71910,
  ATTR_71911 = 71911,
  ATTR_71912 = 71912,
  ATTR_71913 = 71913,
  ATTR_71914 = 71914,
  ATTR_71999 = 71999,
  ATTR_709 = 709,
  ATTR_70901 = 70901,
  ATTR_70902 = 70902,
  ATTR_70903 = 70903,
  ATTR_70904 = 70904,
  ATTR_70905 = 70905,
  ATTR_70906 = 70906,
  ATTR_70907 = 70907,
  ATTR_70908 = 70908,
  ATTR_70909 = 70909,
  ATTR_70910 = 70910,
  ATTR_70911 = 70911,
  ATTR_70913 = 70913,
  ATTR_70915 = 70915,
  ATTR_70917 = 70917,
  ATTR_70918 = 70918,
  ATTR_70999 = 70999,
  ATTR_705 = 705,
  ATTR_70501 = 70501,
  ATTR_70502 = 70502,
  ATTR_70503 = 70503,
  ATTR_70504 = 70504,
  ATTR_70505 = 70505,
  ATTR_70506 = 70506,
  ATTR_70599 = 70599,
  ATTR_721 = 721,
  ATTR_72101 = 72101,
  ATTR_72102 = 72102,
  ATTR_72103 = 72103,
  ATTR_72104 = 72104,
  ATTR_72105 = 72105,
  ATTR_72106 = 72106,
  ATTR_72107 = 72107,
  ATTR_72108 = 72108,
  ATTR_72109 = 72109,
  ATTR_72110 = 72110,
  ATTR_72111 = 72111,
  ATTR_72112 = 72112,
  ATTR_72113 = 72113,
  ATTR_72114 = 72114,
  ATTR_72115 = 72115,
  ATTR_72116 = 72116,
  ATTR_72117 = 72117,
  ATTR_72199 = 72199,
  ATTR_717 = 717,
  ATTR_71701 = 71701,
  ATTR_71702 = 71702,
  ATTR_71703 = 71703,
  ATTR_71704 = 71704,
  ATTR_71705 = 71705,
  ATTR_71706 = 71706,
  ATTR_71707 = 71707,
  ATTR_71708 = 71708,
  ATTR_71799 = 71799,
  ATTR_707 = 707,
  ATTR_70701 = 70701,
  ATTR_70702 = 70702,
  ATTR_70703 = 70703,
  ATTR_70704 = 70704,
  ATTR_70705 = 70705,
  ATTR_70706 = 70706,
  ATTR_70707 = 70707,
  ATTR_70708 = 70708,
  ATTR_70709 = 70709,
  ATTR_70710 = 70710,
  ATTR_70711 = 70711,
  ATTR_70712 = 70712,
  ATTR_70713 = 70713,
  ATTR_70714 = 70714,
  ATTR_70799 = 70799,
  ATTR_708 = 708,
  ATTR_70801 = 70801,
  ATTR_70802 = 70802,
  ATTR_70803 = 70803,
  ATTR_70804 = 70804,
  ATTR_70805 = 70805,
  ATTR_70806 = 70806,
  ATTR_70899 = 70899,
  ATTR_723 = 723,
  ATTR_72301 = 72301,
  ATTR_72302 = 72302,
  ATTR_72303 = 72303,
  ATTR_72304 = 72304,
  ATTR_72305 = 72305,
  ATTR_72306 = 72306,
  ATTR_72307 = 72307,
  ATTR_72308 = 72308,
  ATTR_72309 = 72309,
  ATTR_72310 = 72310,
  ATTR_72311 = 72311,
  ATTR_72312 = 72312,
  ATTR_72313 = 72313,
  ATTR_72314 = 72314,
  ATTR_72315 = 72315,
  ATTR_72399 = 72399,
  ATTR_725 = 725,
  ATTR_72501 = 72501,
  ATTR_72502 = 72502,
  ATTR_72503 = 72503,
  ATTR_72504 = 72504,
  ATTR_72505 = 72505,
  ATTR_72599 = 72599,
  ATTR_799 = 799,
  ATTR_79901 = 79901,
  ATTR_718 = 718,
  ATTR_71801 = 71801,
  ATTR_71802 = 71802,
  ATTR_71803 = 71803,
  ATTR_71804 = 71804,
  ATTR_71805 = 71805,
  ATTR_71806 = 71806,
  ATTR_71807 = 71807,
  ATTR_71808 = 71808,
  ATTR_71809 = 71809,
  ATTR_71810 = 71810,
  ATTR_71811 = 71811,
  ATTR_71812 = 71812,
  ATTR_71813 = 71813,
  ATTR_71814 = 71814,
  ATTR_71815 = 71815,
  ATTR_71816 = 71816,
  ATTR_71817 = 71817,
  ATTR_71818 = 71818,
  ATTR_71819 = 71819,
  ATTR_71820 = 71820,
  ATTR_71821 = 71821,
  ATTR_71822 = 71822,
  ATTR_71899 = 71899,
  ATTR_724 = 724,
  ATTR_72401 = 72401,
  ATTR_72402 = 72402,
  ATTR_72403 = 72403,
  ATTR_72404 = 72404,
  ATTR_72405 = 72405,
  ATTR_72406 = 72406,
  ATTR_72407 = 72407,
  ATTR_72408 = 72408,
  ATTR_72409 = 72409,
  ATTR_72410 = 72410,
  ATTR_72411 = 72411,
  ATTR_72412 = 72412,
  ATTR_72413 = 72413,
  ATTR_72414 = 72414,
  ATTR_72415 = 72415,
  ATTR_72416 = 72416,
  ATTR_72417 = 72417,
  ATTR_72418 = 72418,
  ATTR_72419 = 72419,
  ATTR_72420 = 72420,
  ATTR_72421 = 72421,
  ATTR_72422 = 72422,
  ATTR_72423 = 72423,
  ATTR_72424 = 72424,
  ATTR_72499 = 72499,
  ATTR_716 = 716,
  ATTR_71601 = 71601,
  ATTR_71602 = 71602,
  ATTR_71603 = 71603,
  ATTR_71604 = 71604,
  ATTR_71605 = 71605,
  ATTR_71606 = 71606,
  ATTR_71607 = 71607,
  ATTR_71608 = 71608,
  ATTR_71609 = 71609,
  ATTR_71610 = 71610,
  ATTR_71611 = 71611,
  ATTR_71612 = 71612,
  ATTR_71613 = 71613,
  ATTR_71614 = 71614,
  ATTR_71615 = 71615,
  ATTR_71616 = 71616,
  ATTR_71617 = 71617,
  ATTR_71618 = 71618,
  ATTR_71619 = 71619,
  ATTR_71620 = 71620,
  ATTR_71621 = 71621,
  ATTR_71699 = 71699,
  ATTR_710 = 710,
  ATTR_71001 = 71001,
  ATTR_71002 = 71002,
  ATTR_71003 = 71003,
  ATTR_71004 = 71004,
  ATTR_71005 = 71005,
  ATTR_71006 = 71006,
  ATTR_71007 = 71007,
  ATTR_71008 = 71008,
  ATTR_71099 = 71099,
  ATTR_704 = 704,
  ATTR_70401 = 70401,
  ATTR_70402 = 70402,
  ATTR_70403 = 70403,
  ATTR_70404 = 70404,
  ATTR_70405 = 70405,
  ATTR_70406 = 70406,
  ATTR_70407 = 70407,
  ATTR_70408 = 70408,
  ATTR_70409 = 70409,
  ATTR_70410 = 70410,
  ATTR_70499 = 70499,
  ATTR_703 = 703,
  ATTR_70301 = 70301,
  ATTR_70302 = 70302,
  ATTR_70303 = 70303,
  ATTR_70305 = 70305,
  ATTR_70306 = 70306,
  ATTR_70307 = 70307,
  ATTR_70308 = 70308,
  ATTR_70399 = 70399,
  ATTR_702 = 702,
  ATTR_70201 = 70201,
  ATTR_70202 = 70202,
  ATTR_70203 = 70203,
  ATTR_70204 = 70204,
  ATTR_70205 = 70205,
  ATTR_70206 = 70206,
  ATTR_70207 = 70207,
  ATTR_70208 = 70208,
  ATTR_70209 = 70209,
  ATTR_70210 = 70210,
  ATTR_70212 = 70212,
  ATTR_70299 = 70299,
  ATTR_726 = 726,
  ATTR_72601 = 72601,
  ATTR_72602 = 72602,
  ATTR_72603 = 72603,
  ATTR_72604 = 72604,
  ATTR_72605 = 72605,
  ATTR_72606 = 72606,
  ATTR_72607 = 72607,
  ATTR_72608 = 72608,
  ATTR_72609 = 72609,
  ATTR_72610 = 72610,
  ATTR_72611 = 72611,
  ATTR_72612 = 72612,
  ATTR_72699 = 72699,
  ATTR_714 = 714,
  ATTR_71401 = 71401,
  ATTR_71402 = 71402,
  ATTR_71403 = 71403,
  ATTR_71404 = 71404,
  ATTR_71405 = 71405,
  ATTR_71499 = 71499,
  ATTR_715 = 715,
  ATTR_71501 = 71501,
  ATTR_71502 = 71502,
  ATTR_71503 = 71503,
  ATTR_71504 = 71504,
  ATTR_71505 = 71505,
  ATTR_71506 = 71506,
  ATTR_71507 = 71507,
  ATTR_71508 = 71508,
  ATTR_71509 = 71509,
  ATTR_71510 = 71510,
  ATTR_71511 = 71511,
  ATTR_71512 = 71512,
  ATTR_71514 = 71514,
  ATTR_71515 = 71515,
  ATTR_71516 = 71516,
  ATTR_71599 = 71599,
  ATTR_713 = 713,
  ATTR_71301 = 71301,
  ATTR_71302 = 71302,
  ATTR_71303 = 71303,
  ATTR_71304 = 71304,
  ATTR_71305 = 71305,
  ATTR_71306 = 71306,
  ATTR_71307 = 71307,
  ATTR_71308 = 71308,
  ATTR_71309 = 71309,
  ATTR_71399 = 71399,
  ATTR_712 = 712,
  ATTR_71201 = 71201,
  ATTR_71202 = 71202,
  ATTR_71204 = 71204,
  ATTR_71205 = 71205,
  ATTR_71206 = 71206,
  ATTR_71207 = 71207,
  ATTR_71208 = 71208,
  ATTR_71209 = 71209,
  ATTR_71210 = 71210,
  ATTR_71211 = 71211,
  ATTR_71212 = 71212,
  ATTR_71213 = 71213,
  ATTR_71214 = 71214,
  ATTR_71215 = 71215,
  ATTR_71299 = 71299,
  ATTR_727 = 727,
  ATTR_72701 = 72701,
  ATTR_72702 = 72702,
  ATTR_72703 = 72703,
  ATTR_901 = 901,
  ATTR_90101 = 90101,
  ATTR_90102 = 90102,
  ATTR_90103 = 90103,
  ATTR_90104 = 90104,
  ATTR_90105 = 90105,
  ATTR_90106 = 90106,
  ATTR_90107 = 90107,
  ATTR_90108 = 90108,
  ATTR_90109 = 90109,
  ATTR_90110 = 90110,
  ATTR_90111 = 90111,
  ATTR_90112 = 90112,
  ATTR_90113 = 90113,
  ATTR_90114 = 90114,
  ATTR_90115 = 90115,
  ATTR_90116 = 90116,
  ATTR_90117 = 90117,
  ATTR_90118 = 90118,
  ATTR_90119 = 90119,
  ATTR_90120 = 90120,
  ATTR_90121 = 90121,
  ATTR_90122 = 90122,
  ATTR_90123 = 90123,
  ATTR_90199 = 90199
};
bool CreativeAttribute_IsValid(int value);
const CreativeAttribute CreativeAttribute_MIN = ATTR_701;
const CreativeAttribute CreativeAttribute_MAX = ATTR_90199;
const int CreativeAttribute_ARRAYSIZE = CreativeAttribute_MAX + 1;

const ::google::protobuf::EnumDescriptor* CreativeAttribute_descriptor();
inline const ::std::string& CreativeAttribute_Name(CreativeAttribute value) {
  return ::google::protobuf::internal::NameOfEnum(
    CreativeAttribute_descriptor(), value);
}
inline bool CreativeAttribute_Parse(
    const ::std::string& name, CreativeAttribute* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreativeAttribute>(
    CreativeAttribute_descriptor(), name, value);
}
enum AdPosition {
  UNKNOWN_POSITION = 0,
  ABOVE_TEH_FOLD = 1,
  DEPRECATED = 2,
  BELOW_THE_FOLD = 3,
  HEADER = 4,
  FOOTER = 5,
  SIDEBAR = 6,
  FULL_SCREEN = 7
};
bool AdPosition_IsValid(int value);
const AdPosition AdPosition_MIN = UNKNOWN_POSITION;
const AdPosition AdPosition_MAX = FULL_SCREEN;
const int AdPosition_ARRAYSIZE = AdPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdPosition_descriptor();
inline const ::std::string& AdPosition_Name(AdPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdPosition_descriptor(), value);
}
inline bool AdPosition_Parse(
    const ::std::string& name, AdPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdPosition>(
    AdPosition_descriptor(), name, value);
}
enum ScenarioType {
  CWIFI = 1,
  NETBAR = 2,
  SITES = 3,
  APP = 4
};
bool ScenarioType_IsValid(int value);
const ScenarioType ScenarioType_MIN = CWIFI;
const ScenarioType ScenarioType_MAX = APP;
const int ScenarioType_ARRAYSIZE = ScenarioType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScenarioType_descriptor();
inline const ::std::string& ScenarioType_Name(ScenarioType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScenarioType_descriptor(), value);
}
inline bool ScenarioType_Parse(
    const ::std::string& name, ScenarioType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScenarioType>(
    ScenarioType_descriptor(), name, value);
}
enum ConnectionType {
  UNKNOWN_TYPE = 0,
  ETHERNET = 1,
  WIFI = 2,
  CELLULAR_NETWORK_UNKNOWN_GENERATION = 3,
  CELLULAR_NETWORK_2G = 4,
  CELLULAR_NETWORK_3G = 5,
  CELLULAR_NETWORK_4G = 6
};
bool ConnectionType_IsValid(int value);
const ConnectionType ConnectionType_MIN = UNKNOWN_TYPE;
const ConnectionType ConnectionType_MAX = CELLULAR_NETWORK_4G;
const int ConnectionType_ARRAYSIZE = ConnectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionType_descriptor();
inline const ::std::string& ConnectionType_Name(ConnectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionType_descriptor(), value);
}
inline bool ConnectionType_Parse(
    const ::std::string& name, ConnectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionType>(
    ConnectionType_descriptor(), name, value);
}
enum LocationType {
  GPS = 1,
  IP_ADDRESS = 2,
  USER_PROVIDED = 3
};
bool LocationType_IsValid(int value);
const LocationType LocationType_MIN = GPS;
const LocationType LocationType_MAX = USER_PROVIDED;
const int LocationType_ARRAYSIZE = LocationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocationType_descriptor();
inline const ::std::string& LocationType_Name(LocationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocationType_descriptor(), value);
}
inline bool LocationType_Parse(
    const ::std::string& name, LocationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocationType>(
    LocationType_descriptor(), name, value);
}
enum DeviceType {
  MOBILE = 1,
  PC = 2
};
bool DeviceType_IsValid(int value);
const DeviceType DeviceType_MIN = MOBILE;
const DeviceType DeviceType_MAX = PC;
const int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceType_descriptor();
inline const ::std::string& DeviceType_Name(DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceType_descriptor(), value);
}
inline bool DeviceType_Parse(
    const ::std::string& name, DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum AdmType {
  JSON = 1,
  HTML = 2
};
bool AdmType_IsValid(int value);
const AdmType AdmType_MIN = JSON;
const AdmType AdmType_MAX = HTML;
const int AdmType_ARRAYSIZE = AdmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdmType_descriptor();
inline const ::std::string& AdmType_Name(AdmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdmType_descriptor(), value);
}
inline bool AdmType_Parse(
    const ::std::string& name, AdmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdmType>(
    AdmType_descriptor(), name, value);
}
enum NoBidReasonCodes {
  UNKNOWN_ERROR = 0,
  TECHNICAL_ERROR = 1,
  INVALID_REQUEST = 2
};
bool NoBidReasonCodes_IsValid(int value);
const NoBidReasonCodes NoBidReasonCodes_MIN = UNKNOWN_ERROR;
const NoBidReasonCodes NoBidReasonCodes_MAX = INVALID_REQUEST;
const int NoBidReasonCodes_ARRAYSIZE = NoBidReasonCodes_MAX + 1;

const ::google::protobuf::EnumDescriptor* NoBidReasonCodes_descriptor();
inline const ::std::string& NoBidReasonCodes_Name(NoBidReasonCodes value) {
  return ::google::protobuf::internal::NameOfEnum(
    NoBidReasonCodes_descriptor(), value);
}
inline bool NoBidReasonCodes_Parse(
    const ::std::string& name, NoBidReasonCodes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NoBidReasonCodes>(
    NoBidReasonCodes_descriptor(), name, value);
}
// ===================================================================

class BidRequest : public ::google::protobuf::Message {
 public:
  BidRequest();
  virtual ~BidRequest();

  BidRequest(const BidRequest& from);

  inline BidRequest& operator=(const BidRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BidRequest& default_instance();

  void Swap(BidRequest* other);

  // implements Message ----------------------------------------------

  BidRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BidRequest& from);
  void MergeFrom(const BidRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated .Imp imp = 2;
  inline int imp_size() const;
  inline void clear_imp();
  static const int kImpFieldNumber = 2;
  inline const ::Imp& imp(int index) const;
  inline ::Imp* mutable_imp(int index);
  inline ::Imp* add_imp();
  inline const ::google::protobuf::RepeatedPtrField< ::Imp >&
      imp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Imp >*
      mutable_imp();

  // optional .Site site = 3;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 3;
  inline const ::Site& site() const;
  inline ::Site* mutable_site();
  inline ::Site* release_site();
  inline void set_allocated_site(::Site* site);

  // optional .App app = 4;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 4;
  inline const ::App& app() const;
  inline ::App* mutable_app();
  inline ::App* release_app();
  inline void set_allocated_app(::App* app);

  // optional .User user = 5;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 5;
  inline const ::User& user() const;
  inline ::User* mutable_user();
  inline ::User* release_user();
  inline void set_allocated_user(::User* user);

  // optional .Device device = 6;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 6;
  inline const ::Device& device() const;
  inline ::Device* mutable_device();
  inline ::Device* release_device();
  inline void set_allocated_device(::Device* device);

  // required int32 test = 7 [default = 0];
  inline bool has_test() const;
  inline void clear_test();
  static const int kTestFieldNumber = 7;
  inline ::google::protobuf::int32 test() const;
  inline void set_test(::google::protobuf::int32 value);

  // required int32 tmax = 8;
  inline bool has_tmax() const;
  inline void clear_tmax();
  static const int kTmaxFieldNumber = 8;
  inline ::google::protobuf::int32 tmax() const;
  inline void set_tmax(::google::protobuf::int32 value);

  // required int32 at = 9 [default = 2];
  inline bool has_at() const;
  inline void clear_at();
  static const int kAtFieldNumber = 9;
  inline ::google::protobuf::int32 at() const;
  inline void set_at(::google::protobuf::int32 value);

  // repeated string wseat = 10;
  inline int wseat_size() const;
  inline void clear_wseat();
  static const int kWseatFieldNumber = 10;
  inline const ::std::string& wseat(int index) const;
  inline ::std::string* mutable_wseat(int index);
  inline void set_wseat(int index, const ::std::string& value);
  inline void set_wseat(int index, const char* value);
  inline void set_wseat(int index, const char* value, size_t size);
  inline ::std::string* add_wseat();
  inline void add_wseat(const ::std::string& value);
  inline void add_wseat(const char* value);
  inline void add_wseat(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& wseat() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_wseat();

  // required .Scenario scenario = 11;
  inline bool has_scenario() const;
  inline void clear_scenario();
  static const int kScenarioFieldNumber = 11;
  inline const ::Scenario& scenario() const;
  inline ::Scenario* mutable_scenario();
  inline ::Scenario* release_scenario();
  inline void set_allocated_scenario(::Scenario* scenario);

  // @@protoc_insertion_point(class_scope:BidRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_site();
  inline void clear_has_site();
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_test();
  inline void clear_has_test();
  inline void set_has_tmax();
  inline void clear_has_tmax();
  inline void set_has_at();
  inline void clear_has_at();
  inline void set_has_scenario();
  inline void clear_has_scenario();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::Imp > imp_;
  ::Site* site_;
  ::App* app_;
  ::User* user_;
  ::Device* device_;
  ::google::protobuf::int32 test_;
  ::google::protobuf::int32 tmax_;
  ::google::protobuf::RepeatedPtrField< ::std::string> wseat_;
  ::Scenario* scenario_;
  ::google::protobuf::int32 at_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static BidRequest* default_instance_;
};
// -------------------------------------------------------------------

class Scenario : public ::google::protobuf::Message {
 public:
  Scenario();
  virtual ~Scenario();

  Scenario(const Scenario& from);

  inline Scenario& operator=(const Scenario& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario& default_instance();

  void Swap(Scenario* other);

  // implements Message ----------------------------------------------

  Scenario* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scenario& from);
  void MergeFrom(const Scenario& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ScenarioType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ScenarioType type() const;
  inline void set_type(::ScenarioType value);

  // optional string info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:Scenario)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_;
  int type_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static Scenario* default_instance_;
};
// -------------------------------------------------------------------

class Imp : public ::google::protobuf::Message {
 public:
  Imp();
  virtual ~Imp();

  Imp(const Imp& from);

  inline Imp& operator=(const Imp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Imp& default_instance();

  void Swap(Imp* other);

  // implements Message ----------------------------------------------

  Imp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Imp& from);
  void MergeFrom(const Imp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required .Banner banner = 2;
  inline bool has_banner() const;
  inline void clear_banner();
  static const int kBannerFieldNumber = 2;
  inline const ::Banner& banner() const;
  inline ::Banner* mutable_banner();
  inline ::Banner* release_banner();
  inline void set_allocated_banner(::Banner* banner);

  // required float bidfloor = 3;
  inline bool has_bidfloor() const;
  inline void clear_bidfloor();
  static const int kBidfloorFieldNumber = 3;
  inline float bidfloor() const;
  inline void set_bidfloor(float value);

  // @@protoc_insertion_point(class_scope:Imp)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_banner();
  inline void clear_has_banner();
  inline void set_has_bidfloor();
  inline void clear_has_bidfloor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::Banner* banner_;
  float bidfloor_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static Imp* default_instance_;
};
// -------------------------------------------------------------------

class Banner : public ::google::protobuf::Message {
 public:
  Banner();
  virtual ~Banner();

  Banner(const Banner& from);

  inline Banner& operator=(const Banner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Banner& default_instance();

  void Swap(Banner* other);

  // implements Message ----------------------------------------------

  Banner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Banner& from);
  void MergeFrom(const Banner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 w = 2;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 2;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);

  // optional int32 h = 3;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 3;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);

  // optional int32 wmax = 4;
  inline bool has_wmax() const;
  inline void clear_wmax();
  static const int kWmaxFieldNumber = 4;
  inline ::google::protobuf::int32 wmax() const;
  inline void set_wmax(::google::protobuf::int32 value);

  // optional int32 hmax = 5;
  inline bool has_hmax() const;
  inline void clear_hmax();
  static const int kHmaxFieldNumber = 5;
  inline ::google::protobuf::int32 hmax() const;
  inline void set_hmax(::google::protobuf::int32 value);

  // optional int32 wmin = 6;
  inline bool has_wmin() const;
  inline void clear_wmin();
  static const int kWminFieldNumber = 6;
  inline ::google::protobuf::int32 wmin() const;
  inline void set_wmin(::google::protobuf::int32 value);

  // optional int32 hmin = 7;
  inline bool has_hmin() const;
  inline void clear_hmin();
  static const int kHminFieldNumber = 7;
  inline ::google::protobuf::int32 hmin() const;
  inline void set_hmin(::google::protobuf::int32 value);

  // repeated .AdType btype = 8;
  inline int btype_size() const;
  inline void clear_btype();
  static const int kBtypeFieldNumber = 8;
  inline ::AdType btype(int index) const;
  inline void set_btype(int index, ::AdType value);
  inline void add_btype(::AdType value);
  inline const ::google::protobuf::RepeatedField<int>& btype() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_btype();

  // repeated .AdType wtype = 9;
  inline int wtype_size() const;
  inline void clear_wtype();
  static const int kWtypeFieldNumber = 9;
  inline ::AdType wtype(int index) const;
  inline void set_wtype(int index, ::AdType value);
  inline void add_wtype(::AdType value);
  inline const ::google::protobuf::RepeatedField<int>& wtype() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_wtype();

  // repeated .CreativeAttribute battr = 10;
  inline int battr_size() const;
  inline void clear_battr();
  static const int kBattrFieldNumber = 10;
  inline ::CreativeAttribute battr(int index) const;
  inline void set_battr(int index, ::CreativeAttribute value);
  inline void add_battr(::CreativeAttribute value);
  inline const ::google::protobuf::RepeatedField<int>& battr() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_battr();

  // optional .AdPosition pos = 11;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 11;
  inline ::AdPosition pos() const;
  inline void set_pos(::AdPosition value);

  // repeated string mimes = 12;
  inline int mimes_size() const;
  inline void clear_mimes();
  static const int kMimesFieldNumber = 12;
  inline const ::std::string& mimes(int index) const;
  inline ::std::string* mutable_mimes(int index);
  inline void set_mimes(int index, const ::std::string& value);
  inline void set_mimes(int index, const char* value);
  inline void set_mimes(int index, const char* value, size_t size);
  inline ::std::string* add_mimes();
  inline void add_mimes(const ::std::string& value);
  inline void add_mimes(const char* value);
  inline void add_mimes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mimes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mimes();

  // repeated string keywords = 13;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 13;
  inline const ::std::string& keywords(int index) const;
  inline ::std::string* mutable_keywords(int index);
  inline void set_keywords(int index, const ::std::string& value);
  inline void set_keywords(int index, const char* value);
  inline void set_keywords(int index, const char* value, size_t size);
  inline ::std::string* add_keywords();
  inline void add_keywords(const ::std::string& value);
  inline void add_keywords(const char* value);
  inline void add_keywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // repeated string bwords = 14;
  inline int bwords_size() const;
  inline void clear_bwords();
  static const int kBwordsFieldNumber = 14;
  inline const ::std::string& bwords(int index) const;
  inline ::std::string* mutable_bwords(int index);
  inline void set_bwords(int index, const ::std::string& value);
  inline void set_bwords(int index, const char* value);
  inline void set_bwords(int index, const char* value, size_t size);
  inline ::std::string* add_bwords();
  inline void add_bwords(const ::std::string& value);
  inline void add_bwords(const char* value);
  inline void add_bwords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bwords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bwords();

  // @@protoc_insertion_point(class_scope:Banner)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_wmax();
  inline void clear_has_wmax();
  inline void set_has_hmax();
  inline void clear_has_hmax();
  inline void set_has_wmin();
  inline void clear_has_wmin();
  inline void set_has_hmin();
  inline void clear_has_hmin();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  ::google::protobuf::int32 wmax_;
  ::google::protobuf::int32 hmax_;
  ::google::protobuf::int32 wmin_;
  ::google::protobuf::int32 hmin_;
  ::google::protobuf::RepeatedField<int> btype_;
  ::google::protobuf::RepeatedField<int> wtype_;
  ::google::protobuf::RepeatedField<int> battr_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mimes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bwords_;
  int pos_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static Banner* default_instance_;
};
// -------------------------------------------------------------------

class Site : public ::google::protobuf::Message {
 public:
  Site();
  virtual ~Site();

  Site(const Site& from);

  inline Site& operator=(const Site& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Site& default_instance();

  void Swap(Site* other);

  // implements Message ----------------------------------------------

  Site* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Site& from);
  void MergeFrom(const Site& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string domain = 3;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 3;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // repeated .ContentCategory cat = 4;
  inline int cat_size() const;
  inline void clear_cat();
  static const int kCatFieldNumber = 4;
  inline ::ContentCategory cat(int index) const;
  inline void set_cat(int index, ::ContentCategory value);
  inline void add_cat(::ContentCategory value);
  inline const ::google::protobuf::RepeatedField<int>& cat() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_cat();

  // optional .ContentCategory sectioncat = 5;
  inline bool has_sectioncat() const;
  inline void clear_sectioncat();
  static const int kSectioncatFieldNumber = 5;
  inline ::ContentCategory sectioncat() const;
  inline void set_sectioncat(::ContentCategory value);

  // optional .ContentCategory pagecat = 6;
  inline bool has_pagecat() const;
  inline void clear_pagecat();
  static const int kPagecatFieldNumber = 6;
  inline ::ContentCategory pagecat() const;
  inline void set_pagecat(::ContentCategory value);

  // required string page = 7;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 7;
  inline const ::std::string& page() const;
  inline void set_page(const ::std::string& value);
  inline void set_page(const char* value);
  inline void set_page(const char* value, size_t size);
  inline ::std::string* mutable_page();
  inline ::std::string* release_page();
  inline void set_allocated_page(::std::string* page);

  // optional string ref = 8;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 8;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  inline ::std::string* release_ref();
  inline void set_allocated_ref(::std::string* ref);

  // repeated string search = 9;
  inline int search_size() const;
  inline void clear_search();
  static const int kSearchFieldNumber = 9;
  inline const ::std::string& search(int index) const;
  inline ::std::string* mutable_search(int index);
  inline void set_search(int index, const ::std::string& value);
  inline void set_search(int index, const char* value);
  inline void set_search(int index, const char* value, size_t size);
  inline ::std::string* add_search();
  inline void add_search(const ::std::string& value);
  inline void add_search(const char* value);
  inline void add_search(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& search() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_search();

  // required int32 mobile = 10 [default = 0];
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 10;
  inline ::google::protobuf::int32 mobile() const;
  inline void set_mobile(::google::protobuf::int32 value);

  // required .Publisher publisher = 11;
  inline bool has_publisher() const;
  inline void clear_publisher();
  static const int kPublisherFieldNumber = 11;
  inline const ::Publisher& publisher() const;
  inline ::Publisher* mutable_publisher();
  inline ::Publisher* release_publisher();
  inline void set_allocated_publisher(::Publisher* publisher);

  // repeated string keywords = 12;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 12;
  inline const ::std::string& keywords(int index) const;
  inline ::std::string* mutable_keywords(int index);
  inline void set_keywords(int index, const ::std::string& value);
  inline void set_keywords(int index, const char* value);
  inline void set_keywords(int index, const char* value, size_t size);
  inline ::std::string* add_keywords();
  inline void add_keywords(const ::std::string& value);
  inline void add_keywords(const char* value);
  inline void add_keywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // @@protoc_insertion_point(class_scope:Site)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_sectioncat();
  inline void clear_has_sectioncat();
  inline void set_has_pagecat();
  inline void clear_has_pagecat();
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_publisher();
  inline void clear_has_publisher();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* domain_;
  ::google::protobuf::RepeatedField<int> cat_;
  int sectioncat_;
  int pagecat_;
  ::std::string* page_;
  ::std::string* ref_;
  ::google::protobuf::RepeatedPtrField< ::std::string> search_;
  ::Publisher* publisher_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  ::google::protobuf::int32 mobile_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static Site* default_instance_;
};
// -------------------------------------------------------------------

class App : public ::google::protobuf::Message {
 public:
  App();
  virtual ~App();

  App(const App& from);

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const App& default_instance();

  void Swap(App* other);

  // implements Message ----------------------------------------------

  App* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const App& from);
  void MergeFrom(const App& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string bundle = 3;
  inline bool has_bundle() const;
  inline void clear_bundle();
  static const int kBundleFieldNumber = 3;
  inline const ::std::string& bundle() const;
  inline void set_bundle(const ::std::string& value);
  inline void set_bundle(const char* value);
  inline void set_bundle(const char* value, size_t size);
  inline ::std::string* mutable_bundle();
  inline ::std::string* release_bundle();
  inline void set_allocated_bundle(::std::string* bundle);

  // optional string domain = 4;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 4;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string storeurl = 5;
  inline bool has_storeurl() const;
  inline void clear_storeurl();
  static const int kStoreurlFieldNumber = 5;
  inline const ::std::string& storeurl() const;
  inline void set_storeurl(const ::std::string& value);
  inline void set_storeurl(const char* value);
  inline void set_storeurl(const char* value, size_t size);
  inline ::std::string* mutable_storeurl();
  inline ::std::string* release_storeurl();
  inline void set_allocated_storeurl(::std::string* storeurl);

  // optional .ContentCategory cat = 6;
  inline bool has_cat() const;
  inline void clear_cat();
  static const int kCatFieldNumber = 6;
  inline ::ContentCategory cat() const;
  inline void set_cat(::ContentCategory value);

  // optional .ContentCategory sectioncat = 7;
  inline bool has_sectioncat() const;
  inline void clear_sectioncat();
  static const int kSectioncatFieldNumber = 7;
  inline ::ContentCategory sectioncat() const;
  inline void set_sectioncat(::ContentCategory value);

  // optional .ContentCategory pagecat = 8;
  inline bool has_pagecat() const;
  inline void clear_pagecat();
  static const int kPagecatFieldNumber = 8;
  inline ::ContentCategory pagecat() const;
  inline void set_pagecat(::ContentCategory value);

  // optional string ver = 9;
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 9;
  inline const ::std::string& ver() const;
  inline void set_ver(const ::std::string& value);
  inline void set_ver(const char* value);
  inline void set_ver(const char* value, size_t size);
  inline ::std::string* mutable_ver();
  inline ::std::string* release_ver();
  inline void set_allocated_ver(::std::string* ver);

  // required int32 paid = 10;
  inline bool has_paid() const;
  inline void clear_paid();
  static const int kPaidFieldNumber = 10;
  inline ::google::protobuf::int32 paid() const;
  inline void set_paid(::google::protobuf::int32 value);

  // required .Publisher publisher = 11;
  inline bool has_publisher() const;
  inline void clear_publisher();
  static const int kPublisherFieldNumber = 11;
  inline const ::Publisher& publisher() const;
  inline ::Publisher* mutable_publisher();
  inline ::Publisher* release_publisher();
  inline void set_allocated_publisher(::Publisher* publisher);

  // repeated string keywords = 12;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 12;
  inline const ::std::string& keywords(int index) const;
  inline ::std::string* mutable_keywords(int index);
  inline void set_keywords(int index, const ::std::string& value);
  inline void set_keywords(int index, const char* value);
  inline void set_keywords(int index, const char* value, size_t size);
  inline ::std::string* add_keywords();
  inline void add_keywords(const ::std::string& value);
  inline void add_keywords(const char* value);
  inline void add_keywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // @@protoc_insertion_point(class_scope:App)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bundle();
  inline void clear_has_bundle();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_storeurl();
  inline void clear_has_storeurl();
  inline void set_has_cat();
  inline void clear_has_cat();
  inline void set_has_sectioncat();
  inline void clear_has_sectioncat();
  inline void set_has_pagecat();
  inline void clear_has_pagecat();
  inline void set_has_ver();
  inline void clear_has_ver();
  inline void set_has_paid();
  inline void clear_has_paid();
  inline void set_has_publisher();
  inline void clear_has_publisher();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* bundle_;
  ::std::string* domain_;
  ::std::string* storeurl_;
  int cat_;
  int sectioncat_;
  ::std::string* ver_;
  int pagecat_;
  ::google::protobuf::int32 paid_;
  ::Publisher* publisher_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static App* default_instance_;
};
// -------------------------------------------------------------------

class Publisher : public ::google::protobuf::Message {
 public:
  Publisher();
  virtual ~Publisher();

  Publisher(const Publisher& from);

  inline Publisher& operator=(const Publisher& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Publisher& default_instance();

  void Swap(Publisher* other);

  // implements Message ----------------------------------------------

  Publisher* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Publisher& from);
  void MergeFrom(const Publisher& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .ContentCategory cat = 3;
  inline int cat_size() const;
  inline void clear_cat();
  static const int kCatFieldNumber = 3;
  inline ::ContentCategory cat(int index) const;
  inline void set_cat(int index, ::ContentCategory value);
  inline void add_cat(::ContentCategory value);
  inline const ::google::protobuf::RepeatedField<int>& cat() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_cat();

  // required string domain = 4;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 4;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string slot = 6;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 6;
  inline const ::std::string& slot() const;
  inline void set_slot(const ::std::string& value);
  inline void set_slot(const char* value);
  inline void set_slot(const char* value, size_t size);
  inline ::std::string* mutable_slot();
  inline ::std::string* release_slot();
  inline void set_allocated_slot(::std::string* slot);

  // @@protoc_insertion_point(class_scope:Publisher)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_slot();
  inline void clear_has_slot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::RepeatedField<int> cat_;
  ::std::string* domain_;
  ::std::string* type_;
  ::std::string* slot_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static Publisher* default_instance_;
};
// -------------------------------------------------------------------

class Device : public ::google::protobuf::Message {
 public:
  Device();
  virtual ~Device();

  Device(const Device& from);

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();

  void Swap(Device* other);

  // implements Message ----------------------------------------------

  Device* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ua = 1;
  inline bool has_ua() const;
  inline void clear_ua();
  static const int kUaFieldNumber = 1;
  inline const ::std::string& ua() const;
  inline void set_ua(const ::std::string& value);
  inline void set_ua(const char* value);
  inline void set_ua(const char* value, size_t size);
  inline ::std::string* mutable_ua();
  inline ::std::string* release_ua();
  inline void set_allocated_ua(::std::string* ua);

  // optional .Geo geo = 2;
  inline bool has_geo() const;
  inline void clear_geo();
  static const int kGeoFieldNumber = 2;
  inline const ::Geo& geo() const;
  inline ::Geo* mutable_geo();
  inline ::Geo* release_geo();
  inline void set_allocated_geo(::Geo* geo);

  // required string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required .DeviceType devicetype = 4;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 4;
  inline ::DeviceType devicetype() const;
  inline void set_devicetype(::DeviceType value);

  // optional string make = 5;
  inline bool has_make() const;
  inline void clear_make();
  static const int kMakeFieldNumber = 5;
  inline const ::std::string& make() const;
  inline void set_make(const ::std::string& value);
  inline void set_make(const char* value);
  inline void set_make(const char* value, size_t size);
  inline ::std::string* mutable_make();
  inline ::std::string* release_make();
  inline void set_allocated_make(::std::string* make);

  // optional string model = 6;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 6;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional string hwv = 7;
  inline bool has_hwv() const;
  inline void clear_hwv();
  static const int kHwvFieldNumber = 7;
  inline const ::std::string& hwv() const;
  inline void set_hwv(const ::std::string& value);
  inline void set_hwv(const char* value);
  inline void set_hwv(const char* value, size_t size);
  inline ::std::string* mutable_hwv();
  inline ::std::string* release_hwv();
  inline void set_allocated_hwv(::std::string* hwv);

  // optional string os = 8;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 8;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional string osv = 9;
  inline bool has_osv() const;
  inline void clear_osv();
  static const int kOsvFieldNumber = 9;
  inline const ::std::string& osv() const;
  inline void set_osv(const ::std::string& value);
  inline void set_osv(const char* value);
  inline void set_osv(const char* value, size_t size);
  inline ::std::string* mutable_osv();
  inline ::std::string* release_osv();
  inline void set_allocated_osv(::std::string* osv);

  // required int32 w = 10;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 10;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);

  // required int32 h = 11;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 11;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);

  // optional int32 js = 12 [default = 0];
  inline bool has_js() const;
  inline void clear_js();
  static const int kJsFieldNumber = 12;
  inline ::google::protobuf::int32 js() const;
  inline void set_js(::google::protobuf::int32 value);

  // optional string language = 13;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 13;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional .ConnectionType connectiontype = 14 [default = ETHERNET];
  inline bool has_connectiontype() const;
  inline void clear_connectiontype();
  static const int kConnectiontypeFieldNumber = 14;
  inline ::ConnectionType connectiontype() const;
  inline void set_connectiontype(::ConnectionType value);

  // optional string imei = 15;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 15;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string mac = 16;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 16;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional string idfa = 17;
  inline bool has_idfa() const;
  inline void clear_idfa();
  static const int kIdfaFieldNumber = 17;
  inline const ::std::string& idfa() const;
  inline void set_idfa(const ::std::string& value);
  inline void set_idfa(const char* value);
  inline void set_idfa(const char* value, size_t size);
  inline ::std::string* mutable_idfa();
  inline ::std::string* release_idfa();
  inline void set_allocated_idfa(::std::string* idfa);

  // optional string carrier = 18;
  inline bool has_carrier() const;
  inline void clear_carrier();
  static const int kCarrierFieldNumber = 18;
  inline const ::std::string& carrier() const;
  inline void set_carrier(const ::std::string& value);
  inline void set_carrier(const char* value);
  inline void set_carrier(const char* value, size_t size);
  inline ::std::string* mutable_carrier();
  inline ::std::string* release_carrier();
  inline void set_allocated_carrier(::std::string* carrier);

  // optional string androidid = 19;
  inline bool has_androidid() const;
  inline void clear_androidid();
  static const int kAndroididFieldNumber = 19;
  inline const ::std::string& androidid() const;
  inline void set_androidid(const ::std::string& value);
  inline void set_androidid(const char* value);
  inline void set_androidid(const char* value, size_t size);
  inline ::std::string* mutable_androidid();
  inline ::std::string* release_androidid();
  inline void set_allocated_androidid(::std::string* androidid);

  // @@protoc_insertion_point(class_scope:Device)
 private:
  inline void set_has_ua();
  inline void clear_has_ua();
  inline void set_has_geo();
  inline void clear_has_geo();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_make();
  inline void clear_has_make();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_hwv();
  inline void clear_has_hwv();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_osv();
  inline void clear_has_osv();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_js();
  inline void clear_has_js();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_connectiontype();
  inline void clear_has_connectiontype();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_idfa();
  inline void clear_has_idfa();
  inline void set_has_carrier();
  inline void clear_has_carrier();
  inline void set_has_androidid();
  inline void clear_has_androidid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ua_;
  ::Geo* geo_;
  ::std::string* ip_;
  ::std::string* make_;
  ::std::string* model_;
  ::std::string* hwv_;
  int devicetype_;
  ::google::protobuf::int32 w_;
  ::std::string* os_;
  ::std::string* osv_;
  ::google::protobuf::int32 h_;
  ::google::protobuf::int32 js_;
  ::std::string* language_;
  ::std::string* imei_;
  ::std::string* mac_;
  ::std::string* idfa_;
  ::std::string* carrier_;
  ::std::string* androidid_;
  int connectiontype_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static Device* default_instance_;
};
// -------------------------------------------------------------------

class Geo : public ::google::protobuf::Message {
 public:
  Geo();
  virtual ~Geo();

  Geo(const Geo& from);

  inline Geo& operator=(const Geo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geo& default_instance();

  void Swap(Geo* other);

  // implements Message ----------------------------------------------

  Geo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Geo& from);
  void MergeFrom(const Geo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline float lon() const;
  inline void set_lon(float value);

  // required .LocationType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::LocationType type() const;
  inline void set_type(::LocationType value);

  // optional string country = 4;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 4;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string province = 5;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 5;
  inline const ::std::string& province() const;
  inline void set_province(const ::std::string& value);
  inline void set_province(const char* value);
  inline void set_province(const char* value, size_t size);
  inline ::std::string* mutable_province();
  inline ::std::string* release_province();
  inline void set_allocated_province(::std::string* province);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string zip = 7;
  inline bool has_zip() const;
  inline void clear_zip();
  static const int kZipFieldNumber = 7;
  inline const ::std::string& zip() const;
  inline void set_zip(const ::std::string& value);
  inline void set_zip(const char* value);
  inline void set_zip(const char* value, size_t size);
  inline ::std::string* mutable_zip();
  inline ::std::string* release_zip();
  inline void set_allocated_zip(::std::string* zip);

  // optional int32 utcoffset = 8 [default = 0];
  inline bool has_utcoffset() const;
  inline void clear_utcoffset();
  static const int kUtcoffsetFieldNumber = 8;
  inline ::google::protobuf::int32 utcoffset() const;
  inline void set_utcoffset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Geo)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lon();
  inline void clear_has_lon();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_zip();
  inline void clear_has_zip();
  inline void set_has_utcoffset();
  inline void clear_has_utcoffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float lat_;
  float lon_;
  ::std::string* country_;
  ::std::string* province_;
  int type_;
  ::google::protobuf::int32 utcoffset_;
  ::std::string* city_;
  ::std::string* zip_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static Geo* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 yob = 3;
  inline bool has_yob() const;
  inline void clear_yob();
  static const int kYobFieldNumber = 3;
  inline ::google::protobuf::int32 yob() const;
  inline void set_yob(::google::protobuf::int32 value);

  // optional string gender = 4;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 4;
  inline const ::std::string& gender() const;
  inline void set_gender(const ::std::string& value);
  inline void set_gender(const char* value);
  inline void set_gender(const char* value, size_t size);
  inline ::std::string* mutable_gender();
  inline ::std::string* release_gender();
  inline void set_allocated_gender(::std::string* gender);

  // repeated string keywords = 5;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 5;
  inline const ::std::string& keywords(int index) const;
  inline ::std::string* mutable_keywords(int index);
  inline void set_keywords(int index, const ::std::string& value);
  inline void set_keywords(int index, const char* value);
  inline void set_keywords(int index, const char* value, size_t size);
  inline ::std::string* add_keywords();
  inline void add_keywords(const ::std::string& value);
  inline void add_keywords(const char* value);
  inline void add_keywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // optional .Geo geo = 6;
  inline bool has_geo() const;
  inline void clear_geo();
  static const int kGeoFieldNumber = 6;
  inline const ::Geo& geo() const;
  inline ::Geo* mutable_geo();
  inline ::Geo* release_geo();
  inline void set_allocated_geo(::Geo* geo);

  // @@protoc_insertion_point(class_scope:User)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_yob();
  inline void clear_has_yob();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_geo();
  inline void clear_has_geo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* gender_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  ::Geo* geo_;
  ::google::protobuf::int32 yob_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class BidResponse : public ::google::protobuf::Message {
 public:
  BidResponse();
  virtual ~BidResponse();

  BidResponse(const BidResponse& from);

  inline BidResponse& operator=(const BidResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BidResponse& default_instance();

  void Swap(BidResponse* other);

  // implements Message ----------------------------------------------

  BidResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BidResponse& from);
  void MergeFrom(const BidResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // repeated .SeatBid seatbid = 2;
  inline int seatbid_size() const;
  inline void clear_seatbid();
  static const int kSeatbidFieldNumber = 2;
  inline const ::SeatBid& seatbid(int index) const;
  inline ::SeatBid* mutable_seatbid(int index);
  inline ::SeatBid* add_seatbid();
  inline const ::google::protobuf::RepeatedPtrField< ::SeatBid >&
      seatbid() const;
  inline ::google::protobuf::RepeatedPtrField< ::SeatBid >*
      mutable_seatbid();

  // required string bidid = 3;
  inline bool has_bidid() const;
  inline void clear_bidid();
  static const int kBididFieldNumber = 3;
  inline const ::std::string& bidid() const;
  inline void set_bidid(const ::std::string& value);
  inline void set_bidid(const char* value);
  inline void set_bidid(const char* value, size_t size);
  inline ::std::string* mutable_bidid();
  inline ::std::string* release_bidid();
  inline void set_allocated_bidid(::std::string* bidid);

  // optional .NoBidReasonCodes nbr = 4;
  inline bool has_nbr() const;
  inline void clear_nbr();
  static const int kNbrFieldNumber = 4;
  inline ::NoBidReasonCodes nbr() const;
  inline void set_nbr(::NoBidReasonCodes value);

  // optional int32 process_time = 5;
  inline bool has_process_time() const;
  inline void clear_process_time();
  static const int kProcessTimeFieldNumber = 5;
  inline ::google::protobuf::int32 process_time() const;
  inline void set_process_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BidResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_bidid();
  inline void clear_has_bidid();
  inline void set_has_nbr();
  inline void clear_has_nbr();
  inline void set_has_process_time();
  inline void clear_has_process_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::google::protobuf::RepeatedPtrField< ::SeatBid > seatbid_;
  ::std::string* bidid_;
  int nbr_;
  ::google::protobuf::int32 process_time_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static BidResponse* default_instance_;
};
// -------------------------------------------------------------------

class SeatBid : public ::google::protobuf::Message {
 public:
  SeatBid();
  virtual ~SeatBid();

  SeatBid(const SeatBid& from);

  inline SeatBid& operator=(const SeatBid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SeatBid& default_instance();

  void Swap(SeatBid* other);

  // implements Message ----------------------------------------------

  SeatBid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SeatBid& from);
  void MergeFrom(const SeatBid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bid bid = 1;
  inline int bid_size() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 1;
  inline const ::Bid& bid(int index) const;
  inline ::Bid* mutable_bid(int index);
  inline ::Bid* add_bid();
  inline const ::google::protobuf::RepeatedPtrField< ::Bid >&
      bid() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bid >*
      mutable_bid();

  // required string seat = 2;
  inline bool has_seat() const;
  inline void clear_seat();
  static const int kSeatFieldNumber = 2;
  inline const ::std::string& seat() const;
  inline void set_seat(const ::std::string& value);
  inline void set_seat(const char* value);
  inline void set_seat(const char* value, size_t size);
  inline ::std::string* mutable_seat();
  inline ::std::string* release_seat();
  inline void set_allocated_seat(::std::string* seat);

  // @@protoc_insertion_point(class_scope:SeatBid)
 private:
  inline void set_has_seat();
  inline void clear_has_seat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Bid > bid_;
  ::std::string* seat_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static SeatBid* default_instance_;
};
// -------------------------------------------------------------------

class Bid : public ::google::protobuf::Message {
 public:
  Bid();
  virtual ~Bid();

  Bid(const Bid& from);

  inline Bid& operator=(const Bid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bid& default_instance();

  void Swap(Bid* other);

  // implements Message ----------------------------------------------

  Bid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bid& from);
  void MergeFrom(const Bid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string impid = 2;
  inline bool has_impid() const;
  inline void clear_impid();
  static const int kImpidFieldNumber = 2;
  inline const ::std::string& impid() const;
  inline void set_impid(const ::std::string& value);
  inline void set_impid(const char* value);
  inline void set_impid(const char* value, size_t size);
  inline ::std::string* mutable_impid();
  inline ::std::string* release_impid();
  inline void set_allocated_impid(::std::string* impid);

  // required float price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline float price() const;
  inline void set_price(float value);

  // required string adm = 4;
  inline bool has_adm() const;
  inline void clear_adm();
  static const int kAdmFieldNumber = 4;
  inline const ::std::string& adm() const;
  inline void set_adm(const ::std::string& value);
  inline void set_adm(const char* value);
  inline void set_adm(const char* value, size_t size);
  inline ::std::string* mutable_adm();
  inline ::std::string* release_adm();
  inline void set_allocated_adm(::std::string* adm);

  // required string adomain = 5;
  inline bool has_adomain() const;
  inline void clear_adomain();
  static const int kAdomainFieldNumber = 5;
  inline const ::std::string& adomain() const;
  inline void set_adomain(const ::std::string& value);
  inline void set_adomain(const char* value);
  inline void set_adomain(const char* value, size_t size);
  inline ::std::string* mutable_adomain();
  inline ::std::string* release_adomain();
  inline void set_allocated_adomain(::std::string* adomain);

  // optional string bundle = 6;
  inline bool has_bundle() const;
  inline void clear_bundle();
  static const int kBundleFieldNumber = 6;
  inline const ::std::string& bundle() const;
  inline void set_bundle(const ::std::string& value);
  inline void set_bundle(const char* value);
  inline void set_bundle(const char* value, size_t size);
  inline ::std::string* mutable_bundle();
  inline ::std::string* release_bundle();
  inline void set_allocated_bundle(::std::string* bundle);

  // required string iurl = 7;
  inline bool has_iurl() const;
  inline void clear_iurl();
  static const int kIurlFieldNumber = 7;
  inline const ::std::string& iurl() const;
  inline void set_iurl(const ::std::string& value);
  inline void set_iurl(const char* value);
  inline void set_iurl(const char* value, size_t size);
  inline ::std::string* mutable_iurl();
  inline ::std::string* release_iurl();
  inline void set_allocated_iurl(::std::string* iurl);

  // required float w = 8;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 8;
  inline float w() const;
  inline void set_w(float value);

  // required float h = 9;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 9;
  inline float h() const;
  inline void set_h(float value);

  // optional string adid = 10;
  inline bool has_adid() const;
  inline void clear_adid();
  static const int kAdidFieldNumber = 10;
  inline const ::std::string& adid() const;
  inline void set_adid(const ::std::string& value);
  inline void set_adid(const char* value);
  inline void set_adid(const char* value, size_t size);
  inline ::std::string* mutable_adid();
  inline ::std::string* release_adid();
  inline void set_allocated_adid(::std::string* adid);

  // optional string nurl = 11;
  inline bool has_nurl() const;
  inline void clear_nurl();
  static const int kNurlFieldNumber = 11;
  inline const ::std::string& nurl() const;
  inline void set_nurl(const ::std::string& value);
  inline void set_nurl(const char* value);
  inline void set_nurl(const char* value, size_t size);
  inline ::std::string* mutable_nurl();
  inline ::std::string* release_nurl();
  inline void set_allocated_nurl(::std::string* nurl);

  // optional string cid = 12;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 12;
  inline const ::std::string& cid() const;
  inline void set_cid(const ::std::string& value);
  inline void set_cid(const char* value);
  inline void set_cid(const char* value, size_t size);
  inline ::std::string* mutable_cid();
  inline ::std::string* release_cid();
  inline void set_allocated_cid(::std::string* cid);

  // optional string crid = 13;
  inline bool has_crid() const;
  inline void clear_crid();
  static const int kCridFieldNumber = 13;
  inline const ::std::string& crid() const;
  inline void set_crid(const ::std::string& value);
  inline void set_crid(const char* value);
  inline void set_crid(const char* value, size_t size);
  inline ::std::string* mutable_crid();
  inline ::std::string* release_crid();
  inline void set_allocated_crid(::std::string* crid);

  // optional .ContentCategory cat = 14;
  inline bool has_cat() const;
  inline void clear_cat();
  static const int kCatFieldNumber = 14;
  inline ::ContentCategory cat() const;
  inline void set_cat(::ContentCategory value);

  // optional .CreativeAttribute attr = 15;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 15;
  inline ::CreativeAttribute attr() const;
  inline void set_attr(::CreativeAttribute value);

  // required string curl = 16;
  inline bool has_curl() const;
  inline void clear_curl();
  static const int kCurlFieldNumber = 16;
  inline const ::std::string& curl() const;
  inline void set_curl(const ::std::string& value);
  inline void set_curl(const char* value);
  inline void set_curl(const char* value, size_t size);
  inline ::std::string* mutable_curl();
  inline ::std::string* release_curl();
  inline void set_allocated_curl(::std::string* curl);

  // required .AdType type = 17;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 17;
  inline ::AdType type() const;
  inline void set_type(::AdType value);

  // repeated string extiurl = 18;
  inline int extiurl_size() const;
  inline void clear_extiurl();
  static const int kExtiurlFieldNumber = 18;
  inline const ::std::string& extiurl(int index) const;
  inline ::std::string* mutable_extiurl(int index);
  inline void set_extiurl(int index, const ::std::string& value);
  inline void set_extiurl(int index, const char* value);
  inline void set_extiurl(int index, const char* value, size_t size);
  inline ::std::string* add_extiurl();
  inline void add_extiurl(const ::std::string& value);
  inline void add_extiurl(const char* value);
  inline void add_extiurl(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& extiurl() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_extiurl();

  // optional string action = 19;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 19;
  inline const ::std::string& action() const;
  inline void set_action(const ::std::string& value);
  inline void set_action(const char* value);
  inline void set_action(const char* value, size_t size);
  inline ::std::string* mutable_action();
  inline ::std::string* release_action();
  inline void set_allocated_action(::std::string* action);

  // required .AdmType admtype = 20;
  inline bool has_admtype() const;
  inline void clear_admtype();
  static const int kAdmtypeFieldNumber = 20;
  inline ::AdmType admtype() const;
  inline void set_admtype(::AdmType value);

  // @@protoc_insertion_point(class_scope:Bid)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_impid();
  inline void clear_has_impid();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_adm();
  inline void clear_has_adm();
  inline void set_has_adomain();
  inline void clear_has_adomain();
  inline void set_has_bundle();
  inline void clear_has_bundle();
  inline void set_has_iurl();
  inline void clear_has_iurl();
  inline void set_has_w();
  inline void clear_has_w();
  inline void set_has_h();
  inline void clear_has_h();
  inline void set_has_adid();
  inline void clear_has_adid();
  inline void set_has_nurl();
  inline void clear_has_nurl();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_crid();
  inline void clear_has_crid();
  inline void set_has_cat();
  inline void clear_has_cat();
  inline void set_has_attr();
  inline void clear_has_attr();
  inline void set_has_curl();
  inline void clear_has_curl();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_admtype();
  inline void clear_has_admtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* id_;
  ::std::string* impid_;
  ::std::string* adm_;
  ::std::string* adomain_;
  float price_;
  float w_;
  ::std::string* bundle_;
  ::std::string* iurl_;
  ::std::string* adid_;
  ::std::string* nurl_;
  float h_;
  int cat_;
  ::std::string* cid_;
  ::std::string* crid_;
  ::std::string* curl_;
  int attr_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> extiurl_;
  ::std::string* action_;
  int admtype_;
  friend void  protobuf_AddDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_AssignDesc_openrtb_2dv2_5f6_2eproto();
  friend void protobuf_ShutdownFile_openrtb_2dv2_5f6_2eproto();

  void InitAsDefaultInstance();
  static Bid* default_instance_;
};
// ===================================================================


// ===================================================================

// BidRequest

// required string id = 1;
inline bool BidRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BidRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BidRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BidRequest::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BidRequest::id() const {
  // @@protoc_insertion_point(field_get:BidRequest.id)
  return *id_;
}
inline void BidRequest::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:BidRequest.id)
}
inline void BidRequest::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:BidRequest.id)
}
inline void BidRequest::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BidRequest.id)
}
inline ::std::string* BidRequest::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BidRequest.id)
  return id_;
}
inline ::std::string* BidRequest::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BidRequest::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BidRequest.id)
}

// repeated .Imp imp = 2;
inline int BidRequest::imp_size() const {
  return imp_.size();
}
inline void BidRequest::clear_imp() {
  imp_.Clear();
}
inline const ::Imp& BidRequest::imp(int index) const {
  // @@protoc_insertion_point(field_get:BidRequest.imp)
  return imp_.Get(index);
}
inline ::Imp* BidRequest::mutable_imp(int index) {
  // @@protoc_insertion_point(field_mutable:BidRequest.imp)
  return imp_.Mutable(index);
}
inline ::Imp* BidRequest::add_imp() {
  // @@protoc_insertion_point(field_add:BidRequest.imp)
  return imp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Imp >&
BidRequest::imp() const {
  // @@protoc_insertion_point(field_list:BidRequest.imp)
  return imp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Imp >*
BidRequest::mutable_imp() {
  // @@protoc_insertion_point(field_mutable_list:BidRequest.imp)
  return &imp_;
}

// optional .Site site = 3;
inline bool BidRequest::has_site() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BidRequest::set_has_site() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BidRequest::clear_has_site() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BidRequest::clear_site() {
  if (site_ != NULL) site_->::Site::Clear();
  clear_has_site();
}
inline const ::Site& BidRequest::site() const {
  // @@protoc_insertion_point(field_get:BidRequest.site)
  return site_ != NULL ? *site_ : *default_instance_->site_;
}
inline ::Site* BidRequest::mutable_site() {
  set_has_site();
  if (site_ == NULL) site_ = new ::Site;
  // @@protoc_insertion_point(field_mutable:BidRequest.site)
  return site_;
}
inline ::Site* BidRequest::release_site() {
  clear_has_site();
  ::Site* temp = site_;
  site_ = NULL;
  return temp;
}
inline void BidRequest::set_allocated_site(::Site* site) {
  delete site_;
  site_ = site;
  if (site) {
    set_has_site();
  } else {
    clear_has_site();
  }
  // @@protoc_insertion_point(field_set_allocated:BidRequest.site)
}

// optional .App app = 4;
inline bool BidRequest::has_app() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BidRequest::set_has_app() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BidRequest::clear_has_app() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BidRequest::clear_app() {
  if (app_ != NULL) app_->::App::Clear();
  clear_has_app();
}
inline const ::App& BidRequest::app() const {
  // @@protoc_insertion_point(field_get:BidRequest.app)
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::App* BidRequest::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::App;
  // @@protoc_insertion_point(field_mutable:BidRequest.app)
  return app_;
}
inline ::App* BidRequest::release_app() {
  clear_has_app();
  ::App* temp = app_;
  app_ = NULL;
  return temp;
}
inline void BidRequest::set_allocated_app(::App* app) {
  delete app_;
  app_ = app;
  if (app) {
    set_has_app();
  } else {
    clear_has_app();
  }
  // @@protoc_insertion_point(field_set_allocated:BidRequest.app)
}

// optional .User user = 5;
inline bool BidRequest::has_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BidRequest::set_has_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BidRequest::clear_has_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BidRequest::clear_user() {
  if (user_ != NULL) user_->::User::Clear();
  clear_has_user();
}
inline const ::User& BidRequest::user() const {
  // @@protoc_insertion_point(field_get:BidRequest.user)
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::User* BidRequest::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::User;
  // @@protoc_insertion_point(field_mutable:BidRequest.user)
  return user_;
}
inline ::User* BidRequest::release_user() {
  clear_has_user();
  ::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void BidRequest::set_allocated_user(::User* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
  // @@protoc_insertion_point(field_set_allocated:BidRequest.user)
}

// optional .Device device = 6;
inline bool BidRequest::has_device() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BidRequest::set_has_device() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BidRequest::clear_has_device() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BidRequest::clear_device() {
  if (device_ != NULL) device_->::Device::Clear();
  clear_has_device();
}
inline const ::Device& BidRequest::device() const {
  // @@protoc_insertion_point(field_get:BidRequest.device)
  return device_ != NULL ? *device_ : *default_instance_->device_;
}
inline ::Device* BidRequest::mutable_device() {
  set_has_device();
  if (device_ == NULL) device_ = new ::Device;
  // @@protoc_insertion_point(field_mutable:BidRequest.device)
  return device_;
}
inline ::Device* BidRequest::release_device() {
  clear_has_device();
  ::Device* temp = device_;
  device_ = NULL;
  return temp;
}
inline void BidRequest::set_allocated_device(::Device* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
  // @@protoc_insertion_point(field_set_allocated:BidRequest.device)
}

// required int32 test = 7 [default = 0];
inline bool BidRequest::has_test() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BidRequest::set_has_test() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BidRequest::clear_has_test() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BidRequest::clear_test() {
  test_ = 0;
  clear_has_test();
}
inline ::google::protobuf::int32 BidRequest::test() const {
  // @@protoc_insertion_point(field_get:BidRequest.test)
  return test_;
}
inline void BidRequest::set_test(::google::protobuf::int32 value) {
  set_has_test();
  test_ = value;
  // @@protoc_insertion_point(field_set:BidRequest.test)
}

// required int32 tmax = 8;
inline bool BidRequest::has_tmax() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BidRequest::set_has_tmax() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BidRequest::clear_has_tmax() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BidRequest::clear_tmax() {
  tmax_ = 0;
  clear_has_tmax();
}
inline ::google::protobuf::int32 BidRequest::tmax() const {
  // @@protoc_insertion_point(field_get:BidRequest.tmax)
  return tmax_;
}
inline void BidRequest::set_tmax(::google::protobuf::int32 value) {
  set_has_tmax();
  tmax_ = value;
  // @@protoc_insertion_point(field_set:BidRequest.tmax)
}

// required int32 at = 9 [default = 2];
inline bool BidRequest::has_at() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BidRequest::set_has_at() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BidRequest::clear_has_at() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BidRequest::clear_at() {
  at_ = 2;
  clear_has_at();
}
inline ::google::protobuf::int32 BidRequest::at() const {
  // @@protoc_insertion_point(field_get:BidRequest.at)
  return at_;
}
inline void BidRequest::set_at(::google::protobuf::int32 value) {
  set_has_at();
  at_ = value;
  // @@protoc_insertion_point(field_set:BidRequest.at)
}

// repeated string wseat = 10;
inline int BidRequest::wseat_size() const {
  return wseat_.size();
}
inline void BidRequest::clear_wseat() {
  wseat_.Clear();
}
inline const ::std::string& BidRequest::wseat(int index) const {
  // @@protoc_insertion_point(field_get:BidRequest.wseat)
  return wseat_.Get(index);
}
inline ::std::string* BidRequest::mutable_wseat(int index) {
  // @@protoc_insertion_point(field_mutable:BidRequest.wseat)
  return wseat_.Mutable(index);
}
inline void BidRequest::set_wseat(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:BidRequest.wseat)
  wseat_.Mutable(index)->assign(value);
}
inline void BidRequest::set_wseat(int index, const char* value) {
  wseat_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BidRequest.wseat)
}
inline void BidRequest::set_wseat(int index, const char* value, size_t size) {
  wseat_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BidRequest.wseat)
}
inline ::std::string* BidRequest::add_wseat() {
  return wseat_.Add();
}
inline void BidRequest::add_wseat(const ::std::string& value) {
  wseat_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BidRequest.wseat)
}
inline void BidRequest::add_wseat(const char* value) {
  wseat_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BidRequest.wseat)
}
inline void BidRequest::add_wseat(const char* value, size_t size) {
  wseat_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BidRequest.wseat)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BidRequest::wseat() const {
  // @@protoc_insertion_point(field_list:BidRequest.wseat)
  return wseat_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BidRequest::mutable_wseat() {
  // @@protoc_insertion_point(field_mutable_list:BidRequest.wseat)
  return &wseat_;
}

// required .Scenario scenario = 11;
inline bool BidRequest::has_scenario() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BidRequest::set_has_scenario() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BidRequest::clear_has_scenario() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BidRequest::clear_scenario() {
  if (scenario_ != NULL) scenario_->::Scenario::Clear();
  clear_has_scenario();
}
inline const ::Scenario& BidRequest::scenario() const {
  // @@protoc_insertion_point(field_get:BidRequest.scenario)
  return scenario_ != NULL ? *scenario_ : *default_instance_->scenario_;
}
inline ::Scenario* BidRequest::mutable_scenario() {
  set_has_scenario();
  if (scenario_ == NULL) scenario_ = new ::Scenario;
  // @@protoc_insertion_point(field_mutable:BidRequest.scenario)
  return scenario_;
}
inline ::Scenario* BidRequest::release_scenario() {
  clear_has_scenario();
  ::Scenario* temp = scenario_;
  scenario_ = NULL;
  return temp;
}
inline void BidRequest::set_allocated_scenario(::Scenario* scenario) {
  delete scenario_;
  scenario_ = scenario;
  if (scenario) {
    set_has_scenario();
  } else {
    clear_has_scenario();
  }
  // @@protoc_insertion_point(field_set_allocated:BidRequest.scenario)
}

// -------------------------------------------------------------------

// Scenario

// required .ScenarioType type = 1;
inline bool Scenario::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scenario::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scenario::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scenario::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ScenarioType Scenario::type() const {
  // @@protoc_insertion_point(field_get:Scenario.type)
  return static_cast< ::ScenarioType >(type_);
}
inline void Scenario::set_type(::ScenarioType value) {
  assert(::ScenarioType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Scenario.type)
}

// optional string info = 2;
inline bool Scenario::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scenario::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Scenario::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Scenario::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& Scenario::info() const {
  // @@protoc_insertion_point(field_get:Scenario.info)
  return *info_;
}
inline void Scenario::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:Scenario.info)
}
inline void Scenario::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:Scenario.info)
}
inline void Scenario::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Scenario.info)
}
inline ::std::string* Scenario::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Scenario.info)
  return info_;
}
inline ::std::string* Scenario::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Scenario::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Scenario.info)
}

// -------------------------------------------------------------------

// Imp

// required string id = 1;
inline bool Imp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Imp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Imp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Imp::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Imp::id() const {
  // @@protoc_insertion_point(field_get:Imp.id)
  return *id_;
}
inline void Imp::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Imp.id)
}
inline void Imp::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Imp.id)
}
inline void Imp::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Imp.id)
}
inline ::std::string* Imp::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Imp.id)
  return id_;
}
inline ::std::string* Imp::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Imp::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Imp.id)
}

// required .Banner banner = 2;
inline bool Imp::has_banner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Imp::set_has_banner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Imp::clear_has_banner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Imp::clear_banner() {
  if (banner_ != NULL) banner_->::Banner::Clear();
  clear_has_banner();
}
inline const ::Banner& Imp::banner() const {
  // @@protoc_insertion_point(field_get:Imp.banner)
  return banner_ != NULL ? *banner_ : *default_instance_->banner_;
}
inline ::Banner* Imp::mutable_banner() {
  set_has_banner();
  if (banner_ == NULL) banner_ = new ::Banner;
  // @@protoc_insertion_point(field_mutable:Imp.banner)
  return banner_;
}
inline ::Banner* Imp::release_banner() {
  clear_has_banner();
  ::Banner* temp = banner_;
  banner_ = NULL;
  return temp;
}
inline void Imp::set_allocated_banner(::Banner* banner) {
  delete banner_;
  banner_ = banner;
  if (banner) {
    set_has_banner();
  } else {
    clear_has_banner();
  }
  // @@protoc_insertion_point(field_set_allocated:Imp.banner)
}

// required float bidfloor = 3;
inline bool Imp::has_bidfloor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Imp::set_has_bidfloor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Imp::clear_has_bidfloor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Imp::clear_bidfloor() {
  bidfloor_ = 0;
  clear_has_bidfloor();
}
inline float Imp::bidfloor() const {
  // @@protoc_insertion_point(field_get:Imp.bidfloor)
  return bidfloor_;
}
inline void Imp::set_bidfloor(float value) {
  set_has_bidfloor();
  bidfloor_ = value;
  // @@protoc_insertion_point(field_set:Imp.bidfloor)
}

// -------------------------------------------------------------------

// Banner

// required string id = 1;
inline bool Banner::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Banner::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Banner::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Banner::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Banner::id() const {
  // @@protoc_insertion_point(field_get:Banner.id)
  return *id_;
}
inline void Banner::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Banner.id)
}
inline void Banner::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Banner.id)
}
inline void Banner::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Banner.id)
}
inline ::std::string* Banner::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Banner.id)
  return id_;
}
inline ::std::string* Banner::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Banner::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Banner.id)
}

// optional int32 w = 2;
inline bool Banner::has_w() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Banner::set_has_w() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Banner::clear_has_w() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Banner::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 Banner::w() const {
  // @@protoc_insertion_point(field_get:Banner.w)
  return w_;
}
inline void Banner::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Banner.w)
}

// optional int32 h = 3;
inline bool Banner::has_h() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Banner::set_has_h() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Banner::clear_has_h() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Banner::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 Banner::h() const {
  // @@protoc_insertion_point(field_get:Banner.h)
  return h_;
}
inline void Banner::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
  // @@protoc_insertion_point(field_set:Banner.h)
}

// optional int32 wmax = 4;
inline bool Banner::has_wmax() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Banner::set_has_wmax() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Banner::clear_has_wmax() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Banner::clear_wmax() {
  wmax_ = 0;
  clear_has_wmax();
}
inline ::google::protobuf::int32 Banner::wmax() const {
  // @@protoc_insertion_point(field_get:Banner.wmax)
  return wmax_;
}
inline void Banner::set_wmax(::google::protobuf::int32 value) {
  set_has_wmax();
  wmax_ = value;
  // @@protoc_insertion_point(field_set:Banner.wmax)
}

// optional int32 hmax = 5;
inline bool Banner::has_hmax() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Banner::set_has_hmax() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Banner::clear_has_hmax() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Banner::clear_hmax() {
  hmax_ = 0;
  clear_has_hmax();
}
inline ::google::protobuf::int32 Banner::hmax() const {
  // @@protoc_insertion_point(field_get:Banner.hmax)
  return hmax_;
}
inline void Banner::set_hmax(::google::protobuf::int32 value) {
  set_has_hmax();
  hmax_ = value;
  // @@protoc_insertion_point(field_set:Banner.hmax)
}

// optional int32 wmin = 6;
inline bool Banner::has_wmin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Banner::set_has_wmin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Banner::clear_has_wmin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Banner::clear_wmin() {
  wmin_ = 0;
  clear_has_wmin();
}
inline ::google::protobuf::int32 Banner::wmin() const {
  // @@protoc_insertion_point(field_get:Banner.wmin)
  return wmin_;
}
inline void Banner::set_wmin(::google::protobuf::int32 value) {
  set_has_wmin();
  wmin_ = value;
  // @@protoc_insertion_point(field_set:Banner.wmin)
}

// optional int32 hmin = 7;
inline bool Banner::has_hmin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Banner::set_has_hmin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Banner::clear_has_hmin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Banner::clear_hmin() {
  hmin_ = 0;
  clear_has_hmin();
}
inline ::google::protobuf::int32 Banner::hmin() const {
  // @@protoc_insertion_point(field_get:Banner.hmin)
  return hmin_;
}
inline void Banner::set_hmin(::google::protobuf::int32 value) {
  set_has_hmin();
  hmin_ = value;
  // @@protoc_insertion_point(field_set:Banner.hmin)
}

// repeated .AdType btype = 8;
inline int Banner::btype_size() const {
  return btype_.size();
}
inline void Banner::clear_btype() {
  btype_.Clear();
}
inline ::AdType Banner::btype(int index) const {
  // @@protoc_insertion_point(field_get:Banner.btype)
  return static_cast< ::AdType >(btype_.Get(index));
}
inline void Banner::set_btype(int index, ::AdType value) {
  assert(::AdType_IsValid(value));
  btype_.Set(index, value);
  // @@protoc_insertion_point(field_set:Banner.btype)
}
inline void Banner::add_btype(::AdType value) {
  assert(::AdType_IsValid(value));
  btype_.Add(value);
  // @@protoc_insertion_point(field_add:Banner.btype)
}
inline const ::google::protobuf::RepeatedField<int>&
Banner::btype() const {
  // @@protoc_insertion_point(field_list:Banner.btype)
  return btype_;
}
inline ::google::protobuf::RepeatedField<int>*
Banner::mutable_btype() {
  // @@protoc_insertion_point(field_mutable_list:Banner.btype)
  return &btype_;
}

// repeated .AdType wtype = 9;
inline int Banner::wtype_size() const {
  return wtype_.size();
}
inline void Banner::clear_wtype() {
  wtype_.Clear();
}
inline ::AdType Banner::wtype(int index) const {
  // @@protoc_insertion_point(field_get:Banner.wtype)
  return static_cast< ::AdType >(wtype_.Get(index));
}
inline void Banner::set_wtype(int index, ::AdType value) {
  assert(::AdType_IsValid(value));
  wtype_.Set(index, value);
  // @@protoc_insertion_point(field_set:Banner.wtype)
}
inline void Banner::add_wtype(::AdType value) {
  assert(::AdType_IsValid(value));
  wtype_.Add(value);
  // @@protoc_insertion_point(field_add:Banner.wtype)
}
inline const ::google::protobuf::RepeatedField<int>&
Banner::wtype() const {
  // @@protoc_insertion_point(field_list:Banner.wtype)
  return wtype_;
}
inline ::google::protobuf::RepeatedField<int>*
Banner::mutable_wtype() {
  // @@protoc_insertion_point(field_mutable_list:Banner.wtype)
  return &wtype_;
}

// repeated .CreativeAttribute battr = 10;
inline int Banner::battr_size() const {
  return battr_.size();
}
inline void Banner::clear_battr() {
  battr_.Clear();
}
inline ::CreativeAttribute Banner::battr(int index) const {
  // @@protoc_insertion_point(field_get:Banner.battr)
  return static_cast< ::CreativeAttribute >(battr_.Get(index));
}
inline void Banner::set_battr(int index, ::CreativeAttribute value) {
  assert(::CreativeAttribute_IsValid(value));
  battr_.Set(index, value);
  // @@protoc_insertion_point(field_set:Banner.battr)
}
inline void Banner::add_battr(::CreativeAttribute value) {
  assert(::CreativeAttribute_IsValid(value));
  battr_.Add(value);
  // @@protoc_insertion_point(field_add:Banner.battr)
}
inline const ::google::protobuf::RepeatedField<int>&
Banner::battr() const {
  // @@protoc_insertion_point(field_list:Banner.battr)
  return battr_;
}
inline ::google::protobuf::RepeatedField<int>*
Banner::mutable_battr() {
  // @@protoc_insertion_point(field_mutable_list:Banner.battr)
  return &battr_;
}

// optional .AdPosition pos = 11;
inline bool Banner::has_pos() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Banner::set_has_pos() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Banner::clear_has_pos() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Banner::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::AdPosition Banner::pos() const {
  // @@protoc_insertion_point(field_get:Banner.pos)
  return static_cast< ::AdPosition >(pos_);
}
inline void Banner::set_pos(::AdPosition value) {
  assert(::AdPosition_IsValid(value));
  set_has_pos();
  pos_ = value;
  // @@protoc_insertion_point(field_set:Banner.pos)
}

// repeated string mimes = 12;
inline int Banner::mimes_size() const {
  return mimes_.size();
}
inline void Banner::clear_mimes() {
  mimes_.Clear();
}
inline const ::std::string& Banner::mimes(int index) const {
  // @@protoc_insertion_point(field_get:Banner.mimes)
  return mimes_.Get(index);
}
inline ::std::string* Banner::mutable_mimes(int index) {
  // @@protoc_insertion_point(field_mutable:Banner.mimes)
  return mimes_.Mutable(index);
}
inline void Banner::set_mimes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Banner.mimes)
  mimes_.Mutable(index)->assign(value);
}
inline void Banner::set_mimes(int index, const char* value) {
  mimes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Banner.mimes)
}
inline void Banner::set_mimes(int index, const char* value, size_t size) {
  mimes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Banner.mimes)
}
inline ::std::string* Banner::add_mimes() {
  return mimes_.Add();
}
inline void Banner::add_mimes(const ::std::string& value) {
  mimes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Banner.mimes)
}
inline void Banner::add_mimes(const char* value) {
  mimes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Banner.mimes)
}
inline void Banner::add_mimes(const char* value, size_t size) {
  mimes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Banner.mimes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Banner::mimes() const {
  // @@protoc_insertion_point(field_list:Banner.mimes)
  return mimes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Banner::mutable_mimes() {
  // @@protoc_insertion_point(field_mutable_list:Banner.mimes)
  return &mimes_;
}

// repeated string keywords = 13;
inline int Banner::keywords_size() const {
  return keywords_.size();
}
inline void Banner::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& Banner::keywords(int index) const {
  // @@protoc_insertion_point(field_get:Banner.keywords)
  return keywords_.Get(index);
}
inline ::std::string* Banner::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:Banner.keywords)
  return keywords_.Mutable(index);
}
inline void Banner::set_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Banner.keywords)
  keywords_.Mutable(index)->assign(value);
}
inline void Banner::set_keywords(int index, const char* value) {
  keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Banner.keywords)
}
inline void Banner::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Banner.keywords)
}
inline ::std::string* Banner::add_keywords() {
  return keywords_.Add();
}
inline void Banner::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Banner.keywords)
}
inline void Banner::add_keywords(const char* value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Banner.keywords)
}
inline void Banner::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Banner.keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Banner::keywords() const {
  // @@protoc_insertion_point(field_list:Banner.keywords)
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Banner::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:Banner.keywords)
  return &keywords_;
}

// repeated string bwords = 14;
inline int Banner::bwords_size() const {
  return bwords_.size();
}
inline void Banner::clear_bwords() {
  bwords_.Clear();
}
inline const ::std::string& Banner::bwords(int index) const {
  // @@protoc_insertion_point(field_get:Banner.bwords)
  return bwords_.Get(index);
}
inline ::std::string* Banner::mutable_bwords(int index) {
  // @@protoc_insertion_point(field_mutable:Banner.bwords)
  return bwords_.Mutable(index);
}
inline void Banner::set_bwords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Banner.bwords)
  bwords_.Mutable(index)->assign(value);
}
inline void Banner::set_bwords(int index, const char* value) {
  bwords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Banner.bwords)
}
inline void Banner::set_bwords(int index, const char* value, size_t size) {
  bwords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Banner.bwords)
}
inline ::std::string* Banner::add_bwords() {
  return bwords_.Add();
}
inline void Banner::add_bwords(const ::std::string& value) {
  bwords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Banner.bwords)
}
inline void Banner::add_bwords(const char* value) {
  bwords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Banner.bwords)
}
inline void Banner::add_bwords(const char* value, size_t size) {
  bwords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Banner.bwords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Banner::bwords() const {
  // @@protoc_insertion_point(field_list:Banner.bwords)
  return bwords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Banner::mutable_bwords() {
  // @@protoc_insertion_point(field_mutable_list:Banner.bwords)
  return &bwords_;
}

// -------------------------------------------------------------------

// Site

// required string id = 1;
inline bool Site::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Site::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Site::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Site::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Site::id() const {
  // @@protoc_insertion_point(field_get:Site.id)
  return *id_;
}
inline void Site::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Site.id)
}
inline void Site::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Site.id)
}
inline void Site::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Site.id)
}
inline ::std::string* Site::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Site.id)
  return id_;
}
inline ::std::string* Site::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Site::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Site.id)
}

// optional string name = 2;
inline bool Site::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Site::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Site::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Site::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Site::name() const {
  // @@protoc_insertion_point(field_get:Site.name)
  return *name_;
}
inline void Site::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Site.name)
}
inline void Site::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Site.name)
}
inline void Site::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Site.name)
}
inline ::std::string* Site::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Site.name)
  return name_;
}
inline ::std::string* Site::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Site::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Site.name)
}

// optional string domain = 3;
inline bool Site::has_domain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Site::set_has_domain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Site::clear_has_domain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Site::clear_domain() {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& Site::domain() const {
  // @@protoc_insertion_point(field_get:Site.domain)
  return *domain_;
}
inline void Site::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set:Site.domain)
}
inline void Site::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:Site.domain)
}
inline void Site::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Site.domain)
}
inline ::std::string* Site::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Site.domain)
  return domain_;
}
inline ::std::string* Site::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Site::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Site.domain)
}

// repeated .ContentCategory cat = 4;
inline int Site::cat_size() const {
  return cat_.size();
}
inline void Site::clear_cat() {
  cat_.Clear();
}
inline ::ContentCategory Site::cat(int index) const {
  // @@protoc_insertion_point(field_get:Site.cat)
  return static_cast< ::ContentCategory >(cat_.Get(index));
}
inline void Site::set_cat(int index, ::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  cat_.Set(index, value);
  // @@protoc_insertion_point(field_set:Site.cat)
}
inline void Site::add_cat(::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  cat_.Add(value);
  // @@protoc_insertion_point(field_add:Site.cat)
}
inline const ::google::protobuf::RepeatedField<int>&
Site::cat() const {
  // @@protoc_insertion_point(field_list:Site.cat)
  return cat_;
}
inline ::google::protobuf::RepeatedField<int>*
Site::mutable_cat() {
  // @@protoc_insertion_point(field_mutable_list:Site.cat)
  return &cat_;
}

// optional .ContentCategory sectioncat = 5;
inline bool Site::has_sectioncat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Site::set_has_sectioncat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Site::clear_has_sectioncat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Site::clear_sectioncat() {
  sectioncat_ = 801;
  clear_has_sectioncat();
}
inline ::ContentCategory Site::sectioncat() const {
  // @@protoc_insertion_point(field_get:Site.sectioncat)
  return static_cast< ::ContentCategory >(sectioncat_);
}
inline void Site::set_sectioncat(::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  set_has_sectioncat();
  sectioncat_ = value;
  // @@protoc_insertion_point(field_set:Site.sectioncat)
}

// optional .ContentCategory pagecat = 6;
inline bool Site::has_pagecat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Site::set_has_pagecat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Site::clear_has_pagecat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Site::clear_pagecat() {
  pagecat_ = 801;
  clear_has_pagecat();
}
inline ::ContentCategory Site::pagecat() const {
  // @@protoc_insertion_point(field_get:Site.pagecat)
  return static_cast< ::ContentCategory >(pagecat_);
}
inline void Site::set_pagecat(::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  set_has_pagecat();
  pagecat_ = value;
  // @@protoc_insertion_point(field_set:Site.pagecat)
}

// required string page = 7;
inline bool Site::has_page() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Site::set_has_page() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Site::clear_has_page() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Site::clear_page() {
  if (page_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page_->clear();
  }
  clear_has_page();
}
inline const ::std::string& Site::page() const {
  // @@protoc_insertion_point(field_get:Site.page)
  return *page_;
}
inline void Site::set_page(const ::std::string& value) {
  set_has_page();
  if (page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page_ = new ::std::string;
  }
  page_->assign(value);
  // @@protoc_insertion_point(field_set:Site.page)
}
inline void Site::set_page(const char* value) {
  set_has_page();
  if (page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page_ = new ::std::string;
  }
  page_->assign(value);
  // @@protoc_insertion_point(field_set_char:Site.page)
}
inline void Site::set_page(const char* value, size_t size) {
  set_has_page();
  if (page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page_ = new ::std::string;
  }
  page_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Site.page)
}
inline ::std::string* Site::mutable_page() {
  set_has_page();
  if (page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    page_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Site.page)
  return page_;
}
inline ::std::string* Site::release_page() {
  clear_has_page();
  if (page_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = page_;
    page_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Site::set_allocated_page(::std::string* page) {
  if (page_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete page_;
  }
  if (page) {
    set_has_page();
    page_ = page;
  } else {
    clear_has_page();
    page_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Site.page)
}

// optional string ref = 8;
inline bool Site::has_ref() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Site::set_has_ref() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Site::clear_has_ref() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Site::clear_ref() {
  if (ref_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_->clear();
  }
  clear_has_ref();
}
inline const ::std::string& Site::ref() const {
  // @@protoc_insertion_point(field_get:Site.ref)
  return *ref_;
}
inline void Site::set_ref(const ::std::string& value) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
  // @@protoc_insertion_point(field_set:Site.ref)
}
inline void Site::set_ref(const char* value) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
  // @@protoc_insertion_point(field_set_char:Site.ref)
}
inline void Site::set_ref(const char* value, size_t size) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Site.ref)
}
inline ::std::string* Site::mutable_ref() {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ref_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Site.ref)
  return ref_;
}
inline ::std::string* Site::release_ref() {
  clear_has_ref();
  if (ref_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ref_;
    ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Site::set_allocated_ref(::std::string* ref) {
  if (ref_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ref_;
  }
  if (ref) {
    set_has_ref();
    ref_ = ref;
  } else {
    clear_has_ref();
    ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Site.ref)
}

// repeated string search = 9;
inline int Site::search_size() const {
  return search_.size();
}
inline void Site::clear_search() {
  search_.Clear();
}
inline const ::std::string& Site::search(int index) const {
  // @@protoc_insertion_point(field_get:Site.search)
  return search_.Get(index);
}
inline ::std::string* Site::mutable_search(int index) {
  // @@protoc_insertion_point(field_mutable:Site.search)
  return search_.Mutable(index);
}
inline void Site::set_search(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Site.search)
  search_.Mutable(index)->assign(value);
}
inline void Site::set_search(int index, const char* value) {
  search_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Site.search)
}
inline void Site::set_search(int index, const char* value, size_t size) {
  search_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Site.search)
}
inline ::std::string* Site::add_search() {
  return search_.Add();
}
inline void Site::add_search(const ::std::string& value) {
  search_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Site.search)
}
inline void Site::add_search(const char* value) {
  search_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Site.search)
}
inline void Site::add_search(const char* value, size_t size) {
  search_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Site.search)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Site::search() const {
  // @@protoc_insertion_point(field_list:Site.search)
  return search_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Site::mutable_search() {
  // @@protoc_insertion_point(field_mutable_list:Site.search)
  return &search_;
}

// required int32 mobile = 10 [default = 0];
inline bool Site::has_mobile() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Site::set_has_mobile() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Site::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Site::clear_mobile() {
  mobile_ = 0;
  clear_has_mobile();
}
inline ::google::protobuf::int32 Site::mobile() const {
  // @@protoc_insertion_point(field_get:Site.mobile)
  return mobile_;
}
inline void Site::set_mobile(::google::protobuf::int32 value) {
  set_has_mobile();
  mobile_ = value;
  // @@protoc_insertion_point(field_set:Site.mobile)
}

// required .Publisher publisher = 11;
inline bool Site::has_publisher() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Site::set_has_publisher() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Site::clear_has_publisher() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Site::clear_publisher() {
  if (publisher_ != NULL) publisher_->::Publisher::Clear();
  clear_has_publisher();
}
inline const ::Publisher& Site::publisher() const {
  // @@protoc_insertion_point(field_get:Site.publisher)
  return publisher_ != NULL ? *publisher_ : *default_instance_->publisher_;
}
inline ::Publisher* Site::mutable_publisher() {
  set_has_publisher();
  if (publisher_ == NULL) publisher_ = new ::Publisher;
  // @@protoc_insertion_point(field_mutable:Site.publisher)
  return publisher_;
}
inline ::Publisher* Site::release_publisher() {
  clear_has_publisher();
  ::Publisher* temp = publisher_;
  publisher_ = NULL;
  return temp;
}
inline void Site::set_allocated_publisher(::Publisher* publisher) {
  delete publisher_;
  publisher_ = publisher;
  if (publisher) {
    set_has_publisher();
  } else {
    clear_has_publisher();
  }
  // @@protoc_insertion_point(field_set_allocated:Site.publisher)
}

// repeated string keywords = 12;
inline int Site::keywords_size() const {
  return keywords_.size();
}
inline void Site::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& Site::keywords(int index) const {
  // @@protoc_insertion_point(field_get:Site.keywords)
  return keywords_.Get(index);
}
inline ::std::string* Site::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:Site.keywords)
  return keywords_.Mutable(index);
}
inline void Site::set_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Site.keywords)
  keywords_.Mutable(index)->assign(value);
}
inline void Site::set_keywords(int index, const char* value) {
  keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Site.keywords)
}
inline void Site::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Site.keywords)
}
inline ::std::string* Site::add_keywords() {
  return keywords_.Add();
}
inline void Site::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Site.keywords)
}
inline void Site::add_keywords(const char* value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Site.keywords)
}
inline void Site::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Site.keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Site::keywords() const {
  // @@protoc_insertion_point(field_list:Site.keywords)
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Site::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:Site.keywords)
  return &keywords_;
}

// -------------------------------------------------------------------

// App

// required string id = 1;
inline bool App::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void App::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void App::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void App::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& App::id() const {
  // @@protoc_insertion_point(field_get:App.id)
  return *id_;
}
inline void App::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:App.id)
}
inline void App::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:App.id)
}
inline void App::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:App.id)
}
inline ::std::string* App::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:App.id)
  return id_;
}
inline ::std::string* App::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void App::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:App.id)
}

// optional string name = 2;
inline bool App::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void App::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void App::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void App::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& App::name() const {
  // @@protoc_insertion_point(field_get:App.name)
  return *name_;
}
inline void App::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:App.name)
}
inline void App::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:App.name)
}
inline void App::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:App.name)
}
inline ::std::string* App::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:App.name)
  return name_;
}
inline ::std::string* App::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void App::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:App.name)
}

// required string bundle = 3;
inline bool App::has_bundle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void App::set_has_bundle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void App::clear_has_bundle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void App::clear_bundle() {
  if (bundle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_->clear();
  }
  clear_has_bundle();
}
inline const ::std::string& App::bundle() const {
  // @@protoc_insertion_point(field_get:App.bundle)
  return *bundle_;
}
inline void App::set_bundle(const ::std::string& value) {
  set_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(value);
  // @@protoc_insertion_point(field_set:App.bundle)
}
inline void App::set_bundle(const char* value) {
  set_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(value);
  // @@protoc_insertion_point(field_set_char:App.bundle)
}
inline void App::set_bundle(const char* value, size_t size) {
  set_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:App.bundle)
}
inline ::std::string* App::mutable_bundle() {
  set_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:App.bundle)
  return bundle_;
}
inline ::std::string* App::release_bundle() {
  clear_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bundle_;
    bundle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void App::set_allocated_bundle(::std::string* bundle) {
  if (bundle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bundle_;
  }
  if (bundle) {
    set_has_bundle();
    bundle_ = bundle;
  } else {
    clear_has_bundle();
    bundle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:App.bundle)
}

// optional string domain = 4;
inline bool App::has_domain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void App::set_has_domain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void App::clear_has_domain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void App::clear_domain() {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& App::domain() const {
  // @@protoc_insertion_point(field_get:App.domain)
  return *domain_;
}
inline void App::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set:App.domain)
}
inline void App::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:App.domain)
}
inline void App::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:App.domain)
}
inline ::std::string* App::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:App.domain)
  return domain_;
}
inline ::std::string* App::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void App::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:App.domain)
}

// optional string storeurl = 5;
inline bool App::has_storeurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void App::set_has_storeurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void App::clear_has_storeurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void App::clear_storeurl() {
  if (storeurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storeurl_->clear();
  }
  clear_has_storeurl();
}
inline const ::std::string& App::storeurl() const {
  // @@protoc_insertion_point(field_get:App.storeurl)
  return *storeurl_;
}
inline void App::set_storeurl(const ::std::string& value) {
  set_has_storeurl();
  if (storeurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storeurl_ = new ::std::string;
  }
  storeurl_->assign(value);
  // @@protoc_insertion_point(field_set:App.storeurl)
}
inline void App::set_storeurl(const char* value) {
  set_has_storeurl();
  if (storeurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storeurl_ = new ::std::string;
  }
  storeurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:App.storeurl)
}
inline void App::set_storeurl(const char* value, size_t size) {
  set_has_storeurl();
  if (storeurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storeurl_ = new ::std::string;
  }
  storeurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:App.storeurl)
}
inline ::std::string* App::mutable_storeurl() {
  set_has_storeurl();
  if (storeurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    storeurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:App.storeurl)
  return storeurl_;
}
inline ::std::string* App::release_storeurl() {
  clear_has_storeurl();
  if (storeurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = storeurl_;
    storeurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void App::set_allocated_storeurl(::std::string* storeurl) {
  if (storeurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete storeurl_;
  }
  if (storeurl) {
    set_has_storeurl();
    storeurl_ = storeurl;
  } else {
    clear_has_storeurl();
    storeurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:App.storeurl)
}

// optional .ContentCategory cat = 6;
inline bool App::has_cat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void App::set_has_cat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void App::clear_has_cat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void App::clear_cat() {
  cat_ = 801;
  clear_has_cat();
}
inline ::ContentCategory App::cat() const {
  // @@protoc_insertion_point(field_get:App.cat)
  return static_cast< ::ContentCategory >(cat_);
}
inline void App::set_cat(::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  set_has_cat();
  cat_ = value;
  // @@protoc_insertion_point(field_set:App.cat)
}

// optional .ContentCategory sectioncat = 7;
inline bool App::has_sectioncat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void App::set_has_sectioncat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void App::clear_has_sectioncat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void App::clear_sectioncat() {
  sectioncat_ = 801;
  clear_has_sectioncat();
}
inline ::ContentCategory App::sectioncat() const {
  // @@protoc_insertion_point(field_get:App.sectioncat)
  return static_cast< ::ContentCategory >(sectioncat_);
}
inline void App::set_sectioncat(::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  set_has_sectioncat();
  sectioncat_ = value;
  // @@protoc_insertion_point(field_set:App.sectioncat)
}

// optional .ContentCategory pagecat = 8;
inline bool App::has_pagecat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void App::set_has_pagecat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void App::clear_has_pagecat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void App::clear_pagecat() {
  pagecat_ = 801;
  clear_has_pagecat();
}
inline ::ContentCategory App::pagecat() const {
  // @@protoc_insertion_point(field_get:App.pagecat)
  return static_cast< ::ContentCategory >(pagecat_);
}
inline void App::set_pagecat(::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  set_has_pagecat();
  pagecat_ = value;
  // @@protoc_insertion_point(field_set:App.pagecat)
}

// optional string ver = 9;
inline bool App::has_ver() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void App::set_has_ver() {
  _has_bits_[0] |= 0x00000100u;
}
inline void App::clear_has_ver() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void App::clear_ver() {
  if (ver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ver_->clear();
  }
  clear_has_ver();
}
inline const ::std::string& App::ver() const {
  // @@protoc_insertion_point(field_get:App.ver)
  return *ver_;
}
inline void App::set_ver(const ::std::string& value) {
  set_has_ver();
  if (ver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
  // @@protoc_insertion_point(field_set:App.ver)
}
inline void App::set_ver(const char* value) {
  set_has_ver();
  if (ver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
  // @@protoc_insertion_point(field_set_char:App.ver)
}
inline void App::set_ver(const char* value, size_t size) {
  set_has_ver();
  if (ver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ver_ = new ::std::string;
  }
  ver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:App.ver)
}
inline ::std::string* App::mutable_ver() {
  set_has_ver();
  if (ver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:App.ver)
  return ver_;
}
inline ::std::string* App::release_ver() {
  clear_has_ver();
  if (ver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ver_;
    ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void App::set_allocated_ver(::std::string* ver) {
  if (ver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ver_;
  }
  if (ver) {
    set_has_ver();
    ver_ = ver;
  } else {
    clear_has_ver();
    ver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:App.ver)
}

// required int32 paid = 10;
inline bool App::has_paid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void App::set_has_paid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void App::clear_has_paid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void App::clear_paid() {
  paid_ = 0;
  clear_has_paid();
}
inline ::google::protobuf::int32 App::paid() const {
  // @@protoc_insertion_point(field_get:App.paid)
  return paid_;
}
inline void App::set_paid(::google::protobuf::int32 value) {
  set_has_paid();
  paid_ = value;
  // @@protoc_insertion_point(field_set:App.paid)
}

// required .Publisher publisher = 11;
inline bool App::has_publisher() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void App::set_has_publisher() {
  _has_bits_[0] |= 0x00000400u;
}
inline void App::clear_has_publisher() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void App::clear_publisher() {
  if (publisher_ != NULL) publisher_->::Publisher::Clear();
  clear_has_publisher();
}
inline const ::Publisher& App::publisher() const {
  // @@protoc_insertion_point(field_get:App.publisher)
  return publisher_ != NULL ? *publisher_ : *default_instance_->publisher_;
}
inline ::Publisher* App::mutable_publisher() {
  set_has_publisher();
  if (publisher_ == NULL) publisher_ = new ::Publisher;
  // @@protoc_insertion_point(field_mutable:App.publisher)
  return publisher_;
}
inline ::Publisher* App::release_publisher() {
  clear_has_publisher();
  ::Publisher* temp = publisher_;
  publisher_ = NULL;
  return temp;
}
inline void App::set_allocated_publisher(::Publisher* publisher) {
  delete publisher_;
  publisher_ = publisher;
  if (publisher) {
    set_has_publisher();
  } else {
    clear_has_publisher();
  }
  // @@protoc_insertion_point(field_set_allocated:App.publisher)
}

// repeated string keywords = 12;
inline int App::keywords_size() const {
  return keywords_.size();
}
inline void App::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& App::keywords(int index) const {
  // @@protoc_insertion_point(field_get:App.keywords)
  return keywords_.Get(index);
}
inline ::std::string* App::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:App.keywords)
  return keywords_.Mutable(index);
}
inline void App::set_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:App.keywords)
  keywords_.Mutable(index)->assign(value);
}
inline void App::set_keywords(int index, const char* value) {
  keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:App.keywords)
}
inline void App::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:App.keywords)
}
inline ::std::string* App::add_keywords() {
  return keywords_.Add();
}
inline void App::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:App.keywords)
}
inline void App::add_keywords(const char* value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:App.keywords)
}
inline void App::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:App.keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
App::keywords() const {
  // @@protoc_insertion_point(field_list:App.keywords)
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
App::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:App.keywords)
  return &keywords_;
}

// -------------------------------------------------------------------

// Publisher

// required string id = 1;
inline bool Publisher::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Publisher::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Publisher::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Publisher::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Publisher::id() const {
  // @@protoc_insertion_point(field_get:Publisher.id)
  return *id_;
}
inline void Publisher::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Publisher.id)
}
inline void Publisher::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Publisher.id)
}
inline void Publisher::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Publisher.id)
}
inline ::std::string* Publisher::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Publisher.id)
  return id_;
}
inline ::std::string* Publisher::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publisher::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Publisher.id)
}

// optional string name = 2;
inline bool Publisher::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Publisher::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Publisher::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Publisher::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Publisher::name() const {
  // @@protoc_insertion_point(field_get:Publisher.name)
  return *name_;
}
inline void Publisher::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Publisher.name)
}
inline void Publisher::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Publisher.name)
}
inline void Publisher::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Publisher.name)
}
inline ::std::string* Publisher::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Publisher.name)
  return name_;
}
inline ::std::string* Publisher::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publisher::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Publisher.name)
}

// repeated .ContentCategory cat = 3;
inline int Publisher::cat_size() const {
  return cat_.size();
}
inline void Publisher::clear_cat() {
  cat_.Clear();
}
inline ::ContentCategory Publisher::cat(int index) const {
  // @@protoc_insertion_point(field_get:Publisher.cat)
  return static_cast< ::ContentCategory >(cat_.Get(index));
}
inline void Publisher::set_cat(int index, ::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  cat_.Set(index, value);
  // @@protoc_insertion_point(field_set:Publisher.cat)
}
inline void Publisher::add_cat(::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  cat_.Add(value);
  // @@protoc_insertion_point(field_add:Publisher.cat)
}
inline const ::google::protobuf::RepeatedField<int>&
Publisher::cat() const {
  // @@protoc_insertion_point(field_list:Publisher.cat)
  return cat_;
}
inline ::google::protobuf::RepeatedField<int>*
Publisher::mutable_cat() {
  // @@protoc_insertion_point(field_mutable_list:Publisher.cat)
  return &cat_;
}

// required string domain = 4;
inline bool Publisher::has_domain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Publisher::set_has_domain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Publisher::clear_has_domain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Publisher::clear_domain() {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& Publisher::domain() const {
  // @@protoc_insertion_point(field_get:Publisher.domain)
  return *domain_;
}
inline void Publisher::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set:Publisher.domain)
}
inline void Publisher::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
  // @@protoc_insertion_point(field_set_char:Publisher.domain)
}
inline void Publisher::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Publisher.domain)
}
inline ::std::string* Publisher::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    domain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Publisher.domain)
  return domain_;
}
inline ::std::string* Publisher::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publisher::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Publisher.domain)
}

// optional string type = 5;
inline bool Publisher::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Publisher::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Publisher::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Publisher::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Publisher::type() const {
  // @@protoc_insertion_point(field_get:Publisher.type)
  return *type_;
}
inline void Publisher::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:Publisher.type)
}
inline void Publisher::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:Publisher.type)
}
inline void Publisher::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Publisher.type)
}
inline ::std::string* Publisher::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Publisher.type)
  return type_;
}
inline ::std::string* Publisher::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publisher::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Publisher.type)
}

// optional string slot = 6;
inline bool Publisher::has_slot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Publisher::set_has_slot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Publisher::clear_has_slot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Publisher::clear_slot() {
  if (slot_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slot_->clear();
  }
  clear_has_slot();
}
inline const ::std::string& Publisher::slot() const {
  // @@protoc_insertion_point(field_get:Publisher.slot)
  return *slot_;
}
inline void Publisher::set_slot(const ::std::string& value) {
  set_has_slot();
  if (slot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slot_ = new ::std::string;
  }
  slot_->assign(value);
  // @@protoc_insertion_point(field_set:Publisher.slot)
}
inline void Publisher::set_slot(const char* value) {
  set_has_slot();
  if (slot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slot_ = new ::std::string;
  }
  slot_->assign(value);
  // @@protoc_insertion_point(field_set_char:Publisher.slot)
}
inline void Publisher::set_slot(const char* value, size_t size) {
  set_has_slot();
  if (slot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slot_ = new ::std::string;
  }
  slot_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Publisher.slot)
}
inline ::std::string* Publisher::mutable_slot() {
  set_has_slot();
  if (slot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    slot_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Publisher.slot)
  return slot_;
}
inline ::std::string* Publisher::release_slot() {
  clear_has_slot();
  if (slot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = slot_;
    slot_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Publisher::set_allocated_slot(::std::string* slot) {
  if (slot_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete slot_;
  }
  if (slot) {
    set_has_slot();
    slot_ = slot;
  } else {
    clear_has_slot();
    slot_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Publisher.slot)
}

// -------------------------------------------------------------------

// Device

// required string ua = 1;
inline bool Device::has_ua() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Device::set_has_ua() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Device::clear_has_ua() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Device::clear_ua() {
  if (ua_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ua_->clear();
  }
  clear_has_ua();
}
inline const ::std::string& Device::ua() const {
  // @@protoc_insertion_point(field_get:Device.ua)
  return *ua_;
}
inline void Device::set_ua(const ::std::string& value) {
  set_has_ua();
  if (ua_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ua_ = new ::std::string;
  }
  ua_->assign(value);
  // @@protoc_insertion_point(field_set:Device.ua)
}
inline void Device::set_ua(const char* value) {
  set_has_ua();
  if (ua_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ua_ = new ::std::string;
  }
  ua_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.ua)
}
inline void Device::set_ua(const char* value, size_t size) {
  set_has_ua();
  if (ua_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ua_ = new ::std::string;
  }
  ua_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.ua)
}
inline ::std::string* Device::mutable_ua() {
  set_has_ua();
  if (ua_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ua_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.ua)
  return ua_;
}
inline ::std::string* Device::release_ua() {
  clear_has_ua();
  if (ua_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ua_;
    ua_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_ua(::std::string* ua) {
  if (ua_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ua_;
  }
  if (ua) {
    set_has_ua();
    ua_ = ua;
  } else {
    clear_has_ua();
    ua_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.ua)
}

// optional .Geo geo = 2;
inline bool Device::has_geo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Device::set_has_geo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Device::clear_has_geo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Device::clear_geo() {
  if (geo_ != NULL) geo_->::Geo::Clear();
  clear_has_geo();
}
inline const ::Geo& Device::geo() const {
  // @@protoc_insertion_point(field_get:Device.geo)
  return geo_ != NULL ? *geo_ : *default_instance_->geo_;
}
inline ::Geo* Device::mutable_geo() {
  set_has_geo();
  if (geo_ == NULL) geo_ = new ::Geo;
  // @@protoc_insertion_point(field_mutable:Device.geo)
  return geo_;
}
inline ::Geo* Device::release_geo() {
  clear_has_geo();
  ::Geo* temp = geo_;
  geo_ = NULL;
  return temp;
}
inline void Device::set_allocated_geo(::Geo* geo) {
  delete geo_;
  geo_ = geo;
  if (geo) {
    set_has_geo();
  } else {
    clear_has_geo();
  }
  // @@protoc_insertion_point(field_set_allocated:Device.geo)
}

// required string ip = 3;
inline bool Device::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Device::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Device::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Device::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Device::ip() const {
  // @@protoc_insertion_point(field_get:Device.ip)
  return *ip_;
}
inline void Device::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:Device.ip)
}
inline void Device::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.ip)
}
inline void Device::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.ip)
}
inline ::std::string* Device::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.ip)
  return ip_;
}
inline ::std::string* Device::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.ip)
}

// required .DeviceType devicetype = 4;
inline bool Device::has_devicetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Device::set_has_devicetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Device::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Device::clear_devicetype() {
  devicetype_ = 1;
  clear_has_devicetype();
}
inline ::DeviceType Device::devicetype() const {
  // @@protoc_insertion_point(field_get:Device.devicetype)
  return static_cast< ::DeviceType >(devicetype_);
}
inline void Device::set_devicetype(::DeviceType value) {
  assert(::DeviceType_IsValid(value));
  set_has_devicetype();
  devicetype_ = value;
  // @@protoc_insertion_point(field_set:Device.devicetype)
}

// optional string make = 5;
inline bool Device::has_make() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Device::set_has_make() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Device::clear_has_make() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Device::clear_make() {
  if (make_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    make_->clear();
  }
  clear_has_make();
}
inline const ::std::string& Device::make() const {
  // @@protoc_insertion_point(field_get:Device.make)
  return *make_;
}
inline void Device::set_make(const ::std::string& value) {
  set_has_make();
  if (make_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    make_ = new ::std::string;
  }
  make_->assign(value);
  // @@protoc_insertion_point(field_set:Device.make)
}
inline void Device::set_make(const char* value) {
  set_has_make();
  if (make_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    make_ = new ::std::string;
  }
  make_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.make)
}
inline void Device::set_make(const char* value, size_t size) {
  set_has_make();
  if (make_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    make_ = new ::std::string;
  }
  make_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.make)
}
inline ::std::string* Device::mutable_make() {
  set_has_make();
  if (make_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    make_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.make)
  return make_;
}
inline ::std::string* Device::release_make() {
  clear_has_make();
  if (make_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = make_;
    make_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_make(::std::string* make) {
  if (make_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete make_;
  }
  if (make) {
    set_has_make();
    make_ = make;
  } else {
    clear_has_make();
    make_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.make)
}

// optional string model = 6;
inline bool Device::has_model() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Device::set_has_model() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Device::clear_has_model() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Device::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& Device::model() const {
  // @@protoc_insertion_point(field_get:Device.model)
  return *model_;
}
inline void Device::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:Device.model)
}
inline void Device::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.model)
}
inline void Device::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.model)
}
inline ::std::string* Device::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.model)
  return model_;
}
inline ::std::string* Device::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.model)
}

// optional string hwv = 7;
inline bool Device::has_hwv() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Device::set_has_hwv() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Device::clear_has_hwv() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Device::clear_hwv() {
  if (hwv_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hwv_->clear();
  }
  clear_has_hwv();
}
inline const ::std::string& Device::hwv() const {
  // @@protoc_insertion_point(field_get:Device.hwv)
  return *hwv_;
}
inline void Device::set_hwv(const ::std::string& value) {
  set_has_hwv();
  if (hwv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hwv_ = new ::std::string;
  }
  hwv_->assign(value);
  // @@protoc_insertion_point(field_set:Device.hwv)
}
inline void Device::set_hwv(const char* value) {
  set_has_hwv();
  if (hwv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hwv_ = new ::std::string;
  }
  hwv_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.hwv)
}
inline void Device::set_hwv(const char* value, size_t size) {
  set_has_hwv();
  if (hwv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hwv_ = new ::std::string;
  }
  hwv_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.hwv)
}
inline ::std::string* Device::mutable_hwv() {
  set_has_hwv();
  if (hwv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hwv_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.hwv)
  return hwv_;
}
inline ::std::string* Device::release_hwv() {
  clear_has_hwv();
  if (hwv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hwv_;
    hwv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_hwv(::std::string* hwv) {
  if (hwv_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hwv_;
  }
  if (hwv) {
    set_has_hwv();
    hwv_ = hwv;
  } else {
    clear_has_hwv();
    hwv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.hwv)
}

// optional string os = 8;
inline bool Device::has_os() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Device::set_has_os() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Device::clear_has_os() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Device::clear_os() {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& Device::os() const {
  // @@protoc_insertion_point(field_get:Device.os)
  return *os_;
}
inline void Device::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set:Device.os)
}
inline void Device::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.os)
}
inline void Device::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.os)
}
inline ::std::string* Device::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    os_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.os)
  return os_;
}
inline ::std::string* Device::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.os)
}

// optional string osv = 9;
inline bool Device::has_osv() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Device::set_has_osv() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Device::clear_has_osv() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Device::clear_osv() {
  if (osv_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    osv_->clear();
  }
  clear_has_osv();
}
inline const ::std::string& Device::osv() const {
  // @@protoc_insertion_point(field_get:Device.osv)
  return *osv_;
}
inline void Device::set_osv(const ::std::string& value) {
  set_has_osv();
  if (osv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    osv_ = new ::std::string;
  }
  osv_->assign(value);
  // @@protoc_insertion_point(field_set:Device.osv)
}
inline void Device::set_osv(const char* value) {
  set_has_osv();
  if (osv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    osv_ = new ::std::string;
  }
  osv_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.osv)
}
inline void Device::set_osv(const char* value, size_t size) {
  set_has_osv();
  if (osv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    osv_ = new ::std::string;
  }
  osv_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.osv)
}
inline ::std::string* Device::mutable_osv() {
  set_has_osv();
  if (osv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    osv_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.osv)
  return osv_;
}
inline ::std::string* Device::release_osv() {
  clear_has_osv();
  if (osv_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = osv_;
    osv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_osv(::std::string* osv) {
  if (osv_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete osv_;
  }
  if (osv) {
    set_has_osv();
    osv_ = osv;
  } else {
    clear_has_osv();
    osv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.osv)
}

// required int32 w = 10;
inline bool Device::has_w() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Device::set_has_w() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Device::clear_has_w() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Device::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 Device::w() const {
  // @@protoc_insertion_point(field_get:Device.w)
  return w_;
}
inline void Device::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Device.w)
}

// required int32 h = 11;
inline bool Device::has_h() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Device::set_has_h() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Device::clear_has_h() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Device::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 Device::h() const {
  // @@protoc_insertion_point(field_get:Device.h)
  return h_;
}
inline void Device::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
  // @@protoc_insertion_point(field_set:Device.h)
}

// optional int32 js = 12 [default = 0];
inline bool Device::has_js() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Device::set_has_js() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Device::clear_has_js() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Device::clear_js() {
  js_ = 0;
  clear_has_js();
}
inline ::google::protobuf::int32 Device::js() const {
  // @@protoc_insertion_point(field_get:Device.js)
  return js_;
}
inline void Device::set_js(::google::protobuf::int32 value) {
  set_has_js();
  js_ = value;
  // @@protoc_insertion_point(field_set:Device.js)
}

// optional string language = 13;
inline bool Device::has_language() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Device::set_has_language() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Device::clear_has_language() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Device::clear_language() {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& Device::language() const {
  // @@protoc_insertion_point(field_get:Device.language)
  return *language_;
}
inline void Device::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:Device.language)
}
inline void Device::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.language)
}
inline void Device::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.language)
}
inline ::std::string* Device::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.language)
  return language_;
}
inline ::std::string* Device::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.language)
}

// optional .ConnectionType connectiontype = 14 [default = ETHERNET];
inline bool Device::has_connectiontype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Device::set_has_connectiontype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Device::clear_has_connectiontype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Device::clear_connectiontype() {
  connectiontype_ = 1;
  clear_has_connectiontype();
}
inline ::ConnectionType Device::connectiontype() const {
  // @@protoc_insertion_point(field_get:Device.connectiontype)
  return static_cast< ::ConnectionType >(connectiontype_);
}
inline void Device::set_connectiontype(::ConnectionType value) {
  assert(::ConnectionType_IsValid(value));
  set_has_connectiontype();
  connectiontype_ = value;
  // @@protoc_insertion_point(field_set:Device.connectiontype)
}

// optional string imei = 15;
inline bool Device::has_imei() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Device::set_has_imei() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Device::clear_has_imei() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Device::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& Device::imei() const {
  // @@protoc_insertion_point(field_get:Device.imei)
  return *imei_;
}
inline void Device::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:Device.imei)
}
inline void Device::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.imei)
}
inline void Device::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.imei)
}
inline ::std::string* Device::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.imei)
  return imei_;
}
inline ::std::string* Device::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.imei)
}

// optional string mac = 16;
inline bool Device::has_mac() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Device::set_has_mac() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Device::clear_has_mac() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Device::clear_mac() {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& Device::mac() const {
  // @@protoc_insertion_point(field_get:Device.mac)
  return *mac_;
}
inline void Device::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set:Device.mac)
}
inline void Device::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.mac)
}
inline void Device::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.mac)
}
inline ::std::string* Device::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mac_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.mac)
  return mac_;
}
inline ::std::string* Device::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.mac)
}

// optional string idfa = 17;
inline bool Device::has_idfa() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Device::set_has_idfa() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Device::clear_has_idfa() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Device::clear_idfa() {
  if (idfa_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_->clear();
  }
  clear_has_idfa();
}
inline const ::std::string& Device::idfa() const {
  // @@protoc_insertion_point(field_get:Device.idfa)
  return *idfa_;
}
inline void Device::set_idfa(const ::std::string& value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
  // @@protoc_insertion_point(field_set:Device.idfa)
}
inline void Device::set_idfa(const char* value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.idfa)
}
inline void Device::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.idfa)
}
inline ::std::string* Device::mutable_idfa() {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    idfa_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.idfa)
  return idfa_;
}
inline ::std::string* Device::release_idfa() {
  clear_has_idfa();
  if (idfa_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = idfa_;
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_idfa(::std::string* idfa) {
  if (idfa_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete idfa_;
  }
  if (idfa) {
    set_has_idfa();
    idfa_ = idfa;
  } else {
    clear_has_idfa();
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.idfa)
}

// optional string carrier = 18;
inline bool Device::has_carrier() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Device::set_has_carrier() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Device::clear_has_carrier() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Device::clear_carrier() {
  if (carrier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    carrier_->clear();
  }
  clear_has_carrier();
}
inline const ::std::string& Device::carrier() const {
  // @@protoc_insertion_point(field_get:Device.carrier)
  return *carrier_;
}
inline void Device::set_carrier(const ::std::string& value) {
  set_has_carrier();
  if (carrier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    carrier_ = new ::std::string;
  }
  carrier_->assign(value);
  // @@protoc_insertion_point(field_set:Device.carrier)
}
inline void Device::set_carrier(const char* value) {
  set_has_carrier();
  if (carrier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    carrier_ = new ::std::string;
  }
  carrier_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.carrier)
}
inline void Device::set_carrier(const char* value, size_t size) {
  set_has_carrier();
  if (carrier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    carrier_ = new ::std::string;
  }
  carrier_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.carrier)
}
inline ::std::string* Device::mutable_carrier() {
  set_has_carrier();
  if (carrier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    carrier_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.carrier)
  return carrier_;
}
inline ::std::string* Device::release_carrier() {
  clear_has_carrier();
  if (carrier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = carrier_;
    carrier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_carrier(::std::string* carrier) {
  if (carrier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete carrier_;
  }
  if (carrier) {
    set_has_carrier();
    carrier_ = carrier;
  } else {
    clear_has_carrier();
    carrier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.carrier)
}

// optional string androidid = 19;
inline bool Device::has_androidid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Device::set_has_androidid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Device::clear_has_androidid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Device::clear_androidid() {
  if (androidid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_->clear();
  }
  clear_has_androidid();
}
inline const ::std::string& Device::androidid() const {
  // @@protoc_insertion_point(field_get:Device.androidid)
  return *androidid_;
}
inline void Device::set_androidid(const ::std::string& value) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(value);
  // @@protoc_insertion_point(field_set:Device.androidid)
}
inline void Device::set_androidid(const char* value) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Device.androidid)
}
inline void Device::set_androidid(const char* value, size_t size) {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  androidid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Device.androidid)
}
inline ::std::string* Device::mutable_androidid() {
  set_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    androidid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Device.androidid)
  return androidid_;
}
inline ::std::string* Device::release_androidid() {
  clear_has_androidid();
  if (androidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = androidid_;
    androidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Device::set_allocated_androidid(::std::string* androidid) {
  if (androidid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete androidid_;
  }
  if (androidid) {
    set_has_androidid();
    androidid_ = androidid;
  } else {
    clear_has_androidid();
    androidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Device.androidid)
}

// -------------------------------------------------------------------

// Geo

// optional float lat = 1;
inline bool Geo::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geo::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geo::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geo::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float Geo::lat() const {
  // @@protoc_insertion_point(field_get:Geo.lat)
  return lat_;
}
inline void Geo::set_lat(float value) {
  set_has_lat();
  lat_ = value;
  // @@protoc_insertion_point(field_set:Geo.lat)
}

// optional float lon = 2;
inline bool Geo::has_lon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geo::set_has_lon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geo::clear_has_lon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geo::clear_lon() {
  lon_ = 0;
  clear_has_lon();
}
inline float Geo::lon() const {
  // @@protoc_insertion_point(field_get:Geo.lon)
  return lon_;
}
inline void Geo::set_lon(float value) {
  set_has_lon();
  lon_ = value;
  // @@protoc_insertion_point(field_set:Geo.lon)
}

// required .LocationType type = 3;
inline bool Geo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Geo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Geo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Geo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::LocationType Geo::type() const {
  // @@protoc_insertion_point(field_get:Geo.type)
  return static_cast< ::LocationType >(type_);
}
inline void Geo::set_type(::LocationType value) {
  assert(::LocationType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Geo.type)
}

// optional string country = 4;
inline bool Geo::has_country() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Geo::set_has_country() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Geo::clear_has_country() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Geo::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& Geo::country() const {
  // @@protoc_insertion_point(field_get:Geo.country)
  return *country_;
}
inline void Geo::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:Geo.country)
}
inline void Geo::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:Geo.country)
}
inline void Geo::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Geo.country)
}
inline ::std::string* Geo::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Geo.country)
  return country_;
}
inline ::std::string* Geo::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Geo::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Geo.country)
}

// optional string province = 5;
inline bool Geo::has_province() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Geo::set_has_province() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Geo::clear_has_province() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Geo::clear_province() {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_->clear();
  }
  clear_has_province();
}
inline const ::std::string& Geo::province() const {
  // @@protoc_insertion_point(field_get:Geo.province)
  return *province_;
}
inline void Geo::set_province(const ::std::string& value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set:Geo.province)
}
inline void Geo::set_province(const char* value) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(value);
  // @@protoc_insertion_point(field_set_char:Geo.province)
}
inline void Geo::set_province(const char* value, size_t size) {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  province_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Geo.province)
}
inline ::std::string* Geo::mutable_province() {
  set_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    province_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Geo.province)
  return province_;
}
inline ::std::string* Geo::release_province() {
  clear_has_province();
  if (province_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = province_;
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Geo::set_allocated_province(::std::string* province) {
  if (province_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete province_;
  }
  if (province) {
    set_has_province();
    province_ = province;
  } else {
    clear_has_province();
    province_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Geo.province)
}

// optional string city = 6;
inline bool Geo::has_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Geo::set_has_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Geo::clear_has_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Geo::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& Geo::city() const {
  // @@protoc_insertion_point(field_get:Geo.city)
  return *city_;
}
inline void Geo::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:Geo.city)
}
inline void Geo::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:Geo.city)
}
inline void Geo::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Geo.city)
}
inline ::std::string* Geo::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Geo.city)
  return city_;
}
inline ::std::string* Geo::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Geo::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Geo.city)
}

// optional string zip = 7;
inline bool Geo::has_zip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Geo::set_has_zip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Geo::clear_has_zip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Geo::clear_zip() {
  if (zip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_->clear();
  }
  clear_has_zip();
}
inline const ::std::string& Geo::zip() const {
  // @@protoc_insertion_point(field_get:Geo.zip)
  return *zip_;
}
inline void Geo::set_zip(const ::std::string& value) {
  set_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_ = new ::std::string;
  }
  zip_->assign(value);
  // @@protoc_insertion_point(field_set:Geo.zip)
}
inline void Geo::set_zip(const char* value) {
  set_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_ = new ::std::string;
  }
  zip_->assign(value);
  // @@protoc_insertion_point(field_set_char:Geo.zip)
}
inline void Geo::set_zip(const char* value, size_t size) {
  set_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_ = new ::std::string;
  }
  zip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Geo.zip)
}
inline ::std::string* Geo::mutable_zip() {
  set_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Geo.zip)
  return zip_;
}
inline ::std::string* Geo::release_zip() {
  clear_has_zip();
  if (zip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = zip_;
    zip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Geo::set_allocated_zip(::std::string* zip) {
  if (zip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete zip_;
  }
  if (zip) {
    set_has_zip();
    zip_ = zip;
  } else {
    clear_has_zip();
    zip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Geo.zip)
}

// optional int32 utcoffset = 8 [default = 0];
inline bool Geo::has_utcoffset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Geo::set_has_utcoffset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Geo::clear_has_utcoffset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Geo::clear_utcoffset() {
  utcoffset_ = 0;
  clear_has_utcoffset();
}
inline ::google::protobuf::int32 Geo::utcoffset() const {
  // @@protoc_insertion_point(field_get:Geo.utcoffset)
  return utcoffset_;
}
inline void Geo::set_utcoffset(::google::protobuf::int32 value) {
  set_has_utcoffset();
  utcoffset_ = value;
  // @@protoc_insertion_point(field_set:Geo.utcoffset)
}

// -------------------------------------------------------------------

// User

// required string id = 1;
inline bool User::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& User::id() const {
  // @@protoc_insertion_point(field_get:User.id)
  return *id_;
}
inline void User::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:User.id)
}
inline void User::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:User.id)
}
inline void User::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:User.id)
}
inline ::std::string* User::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:User.id)
  return id_;
}
inline ::std::string* User::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void User::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:User.id)
}

// optional int32 yob = 3;
inline bool User::has_yob() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_yob() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_yob() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_yob() {
  yob_ = 0;
  clear_has_yob();
}
inline ::google::protobuf::int32 User::yob() const {
  // @@protoc_insertion_point(field_get:User.yob)
  return yob_;
}
inline void User::set_yob(::google::protobuf::int32 value) {
  set_has_yob();
  yob_ = value;
  // @@protoc_insertion_point(field_set:User.yob)
}

// optional string gender = 4;
inline bool User::has_gender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_gender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_gender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_gender() {
  if (gender_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gender_->clear();
  }
  clear_has_gender();
}
inline const ::std::string& User::gender() const {
  // @@protoc_insertion_point(field_get:User.gender)
  return *gender_;
}
inline void User::set_gender(const ::std::string& value) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
  // @@protoc_insertion_point(field_set:User.gender)
}
inline void User::set_gender(const char* value) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
  // @@protoc_insertion_point(field_set_char:User.gender)
}
inline void User::set_gender(const char* value, size_t size) {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gender_ = new ::std::string;
  }
  gender_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:User.gender)
}
inline ::std::string* User::mutable_gender() {
  set_has_gender();
  if (gender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    gender_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:User.gender)
  return gender_;
}
inline ::std::string* User::release_gender() {
  clear_has_gender();
  if (gender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = gender_;
    gender_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void User::set_allocated_gender(::std::string* gender) {
  if (gender_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete gender_;
  }
  if (gender) {
    set_has_gender();
    gender_ = gender;
  } else {
    clear_has_gender();
    gender_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:User.gender)
}

// repeated string keywords = 5;
inline int User::keywords_size() const {
  return keywords_.size();
}
inline void User::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& User::keywords(int index) const {
  // @@protoc_insertion_point(field_get:User.keywords)
  return keywords_.Get(index);
}
inline ::std::string* User::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:User.keywords)
  return keywords_.Mutable(index);
}
inline void User::set_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:User.keywords)
  keywords_.Mutable(index)->assign(value);
}
inline void User::set_keywords(int index, const char* value) {
  keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:User.keywords)
}
inline void User::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:User.keywords)
}
inline ::std::string* User::add_keywords() {
  return keywords_.Add();
}
inline void User::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:User.keywords)
}
inline void User::add_keywords(const char* value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:User.keywords)
}
inline void User::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:User.keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
User::keywords() const {
  // @@protoc_insertion_point(field_list:User.keywords)
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
User::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:User.keywords)
  return &keywords_;
}

// optional .Geo geo = 6;
inline bool User::has_geo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_geo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_geo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_geo() {
  if (geo_ != NULL) geo_->::Geo::Clear();
  clear_has_geo();
}
inline const ::Geo& User::geo() const {
  // @@protoc_insertion_point(field_get:User.geo)
  return geo_ != NULL ? *geo_ : *default_instance_->geo_;
}
inline ::Geo* User::mutable_geo() {
  set_has_geo();
  if (geo_ == NULL) geo_ = new ::Geo;
  // @@protoc_insertion_point(field_mutable:User.geo)
  return geo_;
}
inline ::Geo* User::release_geo() {
  clear_has_geo();
  ::Geo* temp = geo_;
  geo_ = NULL;
  return temp;
}
inline void User::set_allocated_geo(::Geo* geo) {
  delete geo_;
  geo_ = geo;
  if (geo) {
    set_has_geo();
  } else {
    clear_has_geo();
  }
  // @@protoc_insertion_point(field_set_allocated:User.geo)
}

// -------------------------------------------------------------------

// BidResponse

// required string id = 1;
inline bool BidResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BidResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BidResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BidResponse::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BidResponse::id() const {
  // @@protoc_insertion_point(field_get:BidResponse.id)
  return *id_;
}
inline void BidResponse::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:BidResponse.id)
}
inline void BidResponse::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:BidResponse.id)
}
inline void BidResponse::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BidResponse.id)
}
inline ::std::string* BidResponse::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BidResponse.id)
  return id_;
}
inline ::std::string* BidResponse::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BidResponse::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BidResponse.id)
}

// repeated .SeatBid seatbid = 2;
inline int BidResponse::seatbid_size() const {
  return seatbid_.size();
}
inline void BidResponse::clear_seatbid() {
  seatbid_.Clear();
}
inline const ::SeatBid& BidResponse::seatbid(int index) const {
  // @@protoc_insertion_point(field_get:BidResponse.seatbid)
  return seatbid_.Get(index);
}
inline ::SeatBid* BidResponse::mutable_seatbid(int index) {
  // @@protoc_insertion_point(field_mutable:BidResponse.seatbid)
  return seatbid_.Mutable(index);
}
inline ::SeatBid* BidResponse::add_seatbid() {
  // @@protoc_insertion_point(field_add:BidResponse.seatbid)
  return seatbid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SeatBid >&
BidResponse::seatbid() const {
  // @@protoc_insertion_point(field_list:BidResponse.seatbid)
  return seatbid_;
}
inline ::google::protobuf::RepeatedPtrField< ::SeatBid >*
BidResponse::mutable_seatbid() {
  // @@protoc_insertion_point(field_mutable_list:BidResponse.seatbid)
  return &seatbid_;
}

// required string bidid = 3;
inline bool BidResponse::has_bidid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BidResponse::set_has_bidid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BidResponse::clear_has_bidid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BidResponse::clear_bidid() {
  if (bidid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bidid_->clear();
  }
  clear_has_bidid();
}
inline const ::std::string& BidResponse::bidid() const {
  // @@protoc_insertion_point(field_get:BidResponse.bidid)
  return *bidid_;
}
inline void BidResponse::set_bidid(const ::std::string& value) {
  set_has_bidid();
  if (bidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bidid_ = new ::std::string;
  }
  bidid_->assign(value);
  // @@protoc_insertion_point(field_set:BidResponse.bidid)
}
inline void BidResponse::set_bidid(const char* value) {
  set_has_bidid();
  if (bidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bidid_ = new ::std::string;
  }
  bidid_->assign(value);
  // @@protoc_insertion_point(field_set_char:BidResponse.bidid)
}
inline void BidResponse::set_bidid(const char* value, size_t size) {
  set_has_bidid();
  if (bidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bidid_ = new ::std::string;
  }
  bidid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BidResponse.bidid)
}
inline ::std::string* BidResponse::mutable_bidid() {
  set_has_bidid();
  if (bidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bidid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:BidResponse.bidid)
  return bidid_;
}
inline ::std::string* BidResponse::release_bidid() {
  clear_has_bidid();
  if (bidid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bidid_;
    bidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BidResponse::set_allocated_bidid(::std::string* bidid) {
  if (bidid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bidid_;
  }
  if (bidid) {
    set_has_bidid();
    bidid_ = bidid;
  } else {
    clear_has_bidid();
    bidid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:BidResponse.bidid)
}

// optional .NoBidReasonCodes nbr = 4;
inline bool BidResponse::has_nbr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BidResponse::set_has_nbr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BidResponse::clear_has_nbr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BidResponse::clear_nbr() {
  nbr_ = 0;
  clear_has_nbr();
}
inline ::NoBidReasonCodes BidResponse::nbr() const {
  // @@protoc_insertion_point(field_get:BidResponse.nbr)
  return static_cast< ::NoBidReasonCodes >(nbr_);
}
inline void BidResponse::set_nbr(::NoBidReasonCodes value) {
  assert(::NoBidReasonCodes_IsValid(value));
  set_has_nbr();
  nbr_ = value;
  // @@protoc_insertion_point(field_set:BidResponse.nbr)
}

// optional int32 process_time = 5;
inline bool BidResponse::has_process_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BidResponse::set_has_process_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BidResponse::clear_has_process_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BidResponse::clear_process_time() {
  process_time_ = 0;
  clear_has_process_time();
}
inline ::google::protobuf::int32 BidResponse::process_time() const {
  // @@protoc_insertion_point(field_get:BidResponse.process_time)
  return process_time_;
}
inline void BidResponse::set_process_time(::google::protobuf::int32 value) {
  set_has_process_time();
  process_time_ = value;
  // @@protoc_insertion_point(field_set:BidResponse.process_time)
}

// -------------------------------------------------------------------

// SeatBid

// repeated .Bid bid = 1;
inline int SeatBid::bid_size() const {
  return bid_.size();
}
inline void SeatBid::clear_bid() {
  bid_.Clear();
}
inline const ::Bid& SeatBid::bid(int index) const {
  // @@protoc_insertion_point(field_get:SeatBid.bid)
  return bid_.Get(index);
}
inline ::Bid* SeatBid::mutable_bid(int index) {
  // @@protoc_insertion_point(field_mutable:SeatBid.bid)
  return bid_.Mutable(index);
}
inline ::Bid* SeatBid::add_bid() {
  // @@protoc_insertion_point(field_add:SeatBid.bid)
  return bid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bid >&
SeatBid::bid() const {
  // @@protoc_insertion_point(field_list:SeatBid.bid)
  return bid_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bid >*
SeatBid::mutable_bid() {
  // @@protoc_insertion_point(field_mutable_list:SeatBid.bid)
  return &bid_;
}

// required string seat = 2;
inline bool SeatBid::has_seat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SeatBid::set_has_seat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SeatBid::clear_has_seat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SeatBid::clear_seat() {
  if (seat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seat_->clear();
  }
  clear_has_seat();
}
inline const ::std::string& SeatBid::seat() const {
  // @@protoc_insertion_point(field_get:SeatBid.seat)
  return *seat_;
}
inline void SeatBid::set_seat(const ::std::string& value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
  // @@protoc_insertion_point(field_set:SeatBid.seat)
}
inline void SeatBid::set_seat(const char* value) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seat_ = new ::std::string;
  }
  seat_->assign(value);
  // @@protoc_insertion_point(field_set_char:SeatBid.seat)
}
inline void SeatBid::set_seat(const char* value, size_t size) {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seat_ = new ::std::string;
  }
  seat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SeatBid.seat)
}
inline ::std::string* SeatBid::mutable_seat() {
  set_has_seat();
  if (seat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    seat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SeatBid.seat)
  return seat_;
}
inline ::std::string* SeatBid::release_seat() {
  clear_has_seat();
  if (seat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = seat_;
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SeatBid::set_allocated_seat(::std::string* seat) {
  if (seat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete seat_;
  }
  if (seat) {
    set_has_seat();
    seat_ = seat;
  } else {
    clear_has_seat();
    seat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SeatBid.seat)
}

// -------------------------------------------------------------------

// Bid

// required string id = 1;
inline bool Bid::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bid::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bid::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bid::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Bid::id() const {
  // @@protoc_insertion_point(field_get:Bid.id)
  return *id_;
}
inline void Bid::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.id)
}
inline void Bid::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.id)
}
inline void Bid::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.id)
}
inline ::std::string* Bid::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.id)
  return id_;
}
inline ::std::string* Bid::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.id)
}

// required string impid = 2;
inline bool Bid::has_impid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bid::set_has_impid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bid::clear_has_impid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bid::clear_impid() {
  if (impid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    impid_->clear();
  }
  clear_has_impid();
}
inline const ::std::string& Bid::impid() const {
  // @@protoc_insertion_point(field_get:Bid.impid)
  return *impid_;
}
inline void Bid::set_impid(const ::std::string& value) {
  set_has_impid();
  if (impid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    impid_ = new ::std::string;
  }
  impid_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.impid)
}
inline void Bid::set_impid(const char* value) {
  set_has_impid();
  if (impid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    impid_ = new ::std::string;
  }
  impid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.impid)
}
inline void Bid::set_impid(const char* value, size_t size) {
  set_has_impid();
  if (impid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    impid_ = new ::std::string;
  }
  impid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.impid)
}
inline ::std::string* Bid::mutable_impid() {
  set_has_impid();
  if (impid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    impid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.impid)
  return impid_;
}
inline ::std::string* Bid::release_impid() {
  clear_has_impid();
  if (impid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = impid_;
    impid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_impid(::std::string* impid) {
  if (impid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete impid_;
  }
  if (impid) {
    set_has_impid();
    impid_ = impid;
  } else {
    clear_has_impid();
    impid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.impid)
}

// required float price = 3;
inline bool Bid::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Bid::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Bid::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Bid::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float Bid::price() const {
  // @@protoc_insertion_point(field_get:Bid.price)
  return price_;
}
inline void Bid::set_price(float value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:Bid.price)
}

// required string adm = 4;
inline bool Bid::has_adm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Bid::set_has_adm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Bid::clear_has_adm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Bid::clear_adm() {
  if (adm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adm_->clear();
  }
  clear_has_adm();
}
inline const ::std::string& Bid::adm() const {
  // @@protoc_insertion_point(field_get:Bid.adm)
  return *adm_;
}
inline void Bid::set_adm(const ::std::string& value) {
  set_has_adm();
  if (adm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adm_ = new ::std::string;
  }
  adm_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.adm)
}
inline void Bid::set_adm(const char* value) {
  set_has_adm();
  if (adm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adm_ = new ::std::string;
  }
  adm_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.adm)
}
inline void Bid::set_adm(const char* value, size_t size) {
  set_has_adm();
  if (adm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adm_ = new ::std::string;
  }
  adm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.adm)
}
inline ::std::string* Bid::mutable_adm() {
  set_has_adm();
  if (adm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.adm)
  return adm_;
}
inline ::std::string* Bid::release_adm() {
  clear_has_adm();
  if (adm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = adm_;
    adm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_adm(::std::string* adm) {
  if (adm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete adm_;
  }
  if (adm) {
    set_has_adm();
    adm_ = adm;
  } else {
    clear_has_adm();
    adm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.adm)
}

// required string adomain = 5;
inline bool Bid::has_adomain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Bid::set_has_adomain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Bid::clear_has_adomain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Bid::clear_adomain() {
  if (adomain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adomain_->clear();
  }
  clear_has_adomain();
}
inline const ::std::string& Bid::adomain() const {
  // @@protoc_insertion_point(field_get:Bid.adomain)
  return *adomain_;
}
inline void Bid::set_adomain(const ::std::string& value) {
  set_has_adomain();
  if (adomain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adomain_ = new ::std::string;
  }
  adomain_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.adomain)
}
inline void Bid::set_adomain(const char* value) {
  set_has_adomain();
  if (adomain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adomain_ = new ::std::string;
  }
  adomain_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.adomain)
}
inline void Bid::set_adomain(const char* value, size_t size) {
  set_has_adomain();
  if (adomain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adomain_ = new ::std::string;
  }
  adomain_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.adomain)
}
inline ::std::string* Bid::mutable_adomain() {
  set_has_adomain();
  if (adomain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adomain_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.adomain)
  return adomain_;
}
inline ::std::string* Bid::release_adomain() {
  clear_has_adomain();
  if (adomain_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = adomain_;
    adomain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_adomain(::std::string* adomain) {
  if (adomain_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete adomain_;
  }
  if (adomain) {
    set_has_adomain();
    adomain_ = adomain;
  } else {
    clear_has_adomain();
    adomain_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.adomain)
}

// optional string bundle = 6;
inline bool Bid::has_bundle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Bid::set_has_bundle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Bid::clear_has_bundle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Bid::clear_bundle() {
  if (bundle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_->clear();
  }
  clear_has_bundle();
}
inline const ::std::string& Bid::bundle() const {
  // @@protoc_insertion_point(field_get:Bid.bundle)
  return *bundle_;
}
inline void Bid::set_bundle(const ::std::string& value) {
  set_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.bundle)
}
inline void Bid::set_bundle(const char* value) {
  set_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.bundle)
}
inline void Bid::set_bundle(const char* value, size_t size) {
  set_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.bundle)
}
inline ::std::string* Bid::mutable_bundle() {
  set_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    bundle_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.bundle)
  return bundle_;
}
inline ::std::string* Bid::release_bundle() {
  clear_has_bundle();
  if (bundle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = bundle_;
    bundle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_bundle(::std::string* bundle) {
  if (bundle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete bundle_;
  }
  if (bundle) {
    set_has_bundle();
    bundle_ = bundle;
  } else {
    clear_has_bundle();
    bundle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.bundle)
}

// required string iurl = 7;
inline bool Bid::has_iurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Bid::set_has_iurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Bid::clear_has_iurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Bid::clear_iurl() {
  if (iurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iurl_->clear();
  }
  clear_has_iurl();
}
inline const ::std::string& Bid::iurl() const {
  // @@protoc_insertion_point(field_get:Bid.iurl)
  return *iurl_;
}
inline void Bid::set_iurl(const ::std::string& value) {
  set_has_iurl();
  if (iurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iurl_ = new ::std::string;
  }
  iurl_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.iurl)
}
inline void Bid::set_iurl(const char* value) {
  set_has_iurl();
  if (iurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iurl_ = new ::std::string;
  }
  iurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.iurl)
}
inline void Bid::set_iurl(const char* value, size_t size) {
  set_has_iurl();
  if (iurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iurl_ = new ::std::string;
  }
  iurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.iurl)
}
inline ::std::string* Bid::mutable_iurl() {
  set_has_iurl();
  if (iurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.iurl)
  return iurl_;
}
inline ::std::string* Bid::release_iurl() {
  clear_has_iurl();
  if (iurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = iurl_;
    iurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_iurl(::std::string* iurl) {
  if (iurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iurl_;
  }
  if (iurl) {
    set_has_iurl();
    iurl_ = iurl;
  } else {
    clear_has_iurl();
    iurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.iurl)
}

// required float w = 8;
inline bool Bid::has_w() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Bid::set_has_w() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Bid::clear_has_w() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Bid::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Bid::w() const {
  // @@protoc_insertion_point(field_get:Bid.w)
  return w_;
}
inline void Bid::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:Bid.w)
}

// required float h = 9;
inline bool Bid::has_h() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Bid::set_has_h() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Bid::clear_has_h() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Bid::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline float Bid::h() const {
  // @@protoc_insertion_point(field_get:Bid.h)
  return h_;
}
inline void Bid::set_h(float value) {
  set_has_h();
  h_ = value;
  // @@protoc_insertion_point(field_set:Bid.h)
}

// optional string adid = 10;
inline bool Bid::has_adid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Bid::set_has_adid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Bid::clear_has_adid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Bid::clear_adid() {
  if (adid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adid_->clear();
  }
  clear_has_adid();
}
inline const ::std::string& Bid::adid() const {
  // @@protoc_insertion_point(field_get:Bid.adid)
  return *adid_;
}
inline void Bid::set_adid(const ::std::string& value) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adid_ = new ::std::string;
  }
  adid_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.adid)
}
inline void Bid::set_adid(const char* value) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adid_ = new ::std::string;
  }
  adid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.adid)
}
inline void Bid::set_adid(const char* value, size_t size) {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adid_ = new ::std::string;
  }
  adid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.adid)
}
inline ::std::string* Bid::mutable_adid() {
  set_has_adid();
  if (adid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    adid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.adid)
  return adid_;
}
inline ::std::string* Bid::release_adid() {
  clear_has_adid();
  if (adid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = adid_;
    adid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_adid(::std::string* adid) {
  if (adid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete adid_;
  }
  if (adid) {
    set_has_adid();
    adid_ = adid;
  } else {
    clear_has_adid();
    adid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.adid)
}

// optional string nurl = 11;
inline bool Bid::has_nurl() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Bid::set_has_nurl() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Bid::clear_has_nurl() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Bid::clear_nurl() {
  if (nurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nurl_->clear();
  }
  clear_has_nurl();
}
inline const ::std::string& Bid::nurl() const {
  // @@protoc_insertion_point(field_get:Bid.nurl)
  return *nurl_;
}
inline void Bid::set_nurl(const ::std::string& value) {
  set_has_nurl();
  if (nurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nurl_ = new ::std::string;
  }
  nurl_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.nurl)
}
inline void Bid::set_nurl(const char* value) {
  set_has_nurl();
  if (nurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nurl_ = new ::std::string;
  }
  nurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.nurl)
}
inline void Bid::set_nurl(const char* value, size_t size) {
  set_has_nurl();
  if (nurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nurl_ = new ::std::string;
  }
  nurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.nurl)
}
inline ::std::string* Bid::mutable_nurl() {
  set_has_nurl();
  if (nurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.nurl)
  return nurl_;
}
inline ::std::string* Bid::release_nurl() {
  clear_has_nurl();
  if (nurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nurl_;
    nurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_nurl(::std::string* nurl) {
  if (nurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nurl_;
  }
  if (nurl) {
    set_has_nurl();
    nurl_ = nurl;
  } else {
    clear_has_nurl();
    nurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.nurl)
}

// optional string cid = 12;
inline bool Bid::has_cid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Bid::set_has_cid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Bid::clear_has_cid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Bid::clear_cid() {
  if (cid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_->clear();
  }
  clear_has_cid();
}
inline const ::std::string& Bid::cid() const {
  // @@protoc_insertion_point(field_get:Bid.cid)
  return *cid_;
}
inline void Bid::set_cid(const ::std::string& value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.cid)
}
inline void Bid::set_cid(const char* value) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_ = new ::std::string;
  }
  cid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.cid)
}
inline void Bid::set_cid(const char* value, size_t size) {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_ = new ::std::string;
  }
  cid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.cid)
}
inline ::std::string* Bid::mutable_cid() {
  set_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.cid)
  return cid_;
}
inline ::std::string* Bid::release_cid() {
  clear_has_cid();
  if (cid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cid_;
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_cid(::std::string* cid) {
  if (cid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cid_;
  }
  if (cid) {
    set_has_cid();
    cid_ = cid;
  } else {
    clear_has_cid();
    cid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.cid)
}

// optional string crid = 13;
inline bool Bid::has_crid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Bid::set_has_crid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Bid::clear_has_crid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Bid::clear_crid() {
  if (crid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crid_->clear();
  }
  clear_has_crid();
}
inline const ::std::string& Bid::crid() const {
  // @@protoc_insertion_point(field_get:Bid.crid)
  return *crid_;
}
inline void Bid::set_crid(const ::std::string& value) {
  set_has_crid();
  if (crid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crid_ = new ::std::string;
  }
  crid_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.crid)
}
inline void Bid::set_crid(const char* value) {
  set_has_crid();
  if (crid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crid_ = new ::std::string;
  }
  crid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.crid)
}
inline void Bid::set_crid(const char* value, size_t size) {
  set_has_crid();
  if (crid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crid_ = new ::std::string;
  }
  crid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.crid)
}
inline ::std::string* Bid::mutable_crid() {
  set_has_crid();
  if (crid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    crid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.crid)
  return crid_;
}
inline ::std::string* Bid::release_crid() {
  clear_has_crid();
  if (crid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = crid_;
    crid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_crid(::std::string* crid) {
  if (crid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete crid_;
  }
  if (crid) {
    set_has_crid();
    crid_ = crid;
  } else {
    clear_has_crid();
    crid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.crid)
}

// optional .ContentCategory cat = 14;
inline bool Bid::has_cat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Bid::set_has_cat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Bid::clear_has_cat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Bid::clear_cat() {
  cat_ = 801;
  clear_has_cat();
}
inline ::ContentCategory Bid::cat() const {
  // @@protoc_insertion_point(field_get:Bid.cat)
  return static_cast< ::ContentCategory >(cat_);
}
inline void Bid::set_cat(::ContentCategory value) {
  assert(::ContentCategory_IsValid(value));
  set_has_cat();
  cat_ = value;
  // @@protoc_insertion_point(field_set:Bid.cat)
}

// optional .CreativeAttribute attr = 15;
inline bool Bid::has_attr() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Bid::set_has_attr() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Bid::clear_has_attr() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Bid::clear_attr() {
  attr_ = 706;
  clear_has_attr();
}
inline ::CreativeAttribute Bid::attr() const {
  // @@protoc_insertion_point(field_get:Bid.attr)
  return static_cast< ::CreativeAttribute >(attr_);
}
inline void Bid::set_attr(::CreativeAttribute value) {
  assert(::CreativeAttribute_IsValid(value));
  set_has_attr();
  attr_ = value;
  // @@protoc_insertion_point(field_set:Bid.attr)
}

// required string curl = 16;
inline bool Bid::has_curl() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Bid::set_has_curl() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Bid::clear_has_curl() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Bid::clear_curl() {
  if (curl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    curl_->clear();
  }
  clear_has_curl();
}
inline const ::std::string& Bid::curl() const {
  // @@protoc_insertion_point(field_get:Bid.curl)
  return *curl_;
}
inline void Bid::set_curl(const ::std::string& value) {
  set_has_curl();
  if (curl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    curl_ = new ::std::string;
  }
  curl_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.curl)
}
inline void Bid::set_curl(const char* value) {
  set_has_curl();
  if (curl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    curl_ = new ::std::string;
  }
  curl_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.curl)
}
inline void Bid::set_curl(const char* value, size_t size) {
  set_has_curl();
  if (curl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    curl_ = new ::std::string;
  }
  curl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.curl)
}
inline ::std::string* Bid::mutable_curl() {
  set_has_curl();
  if (curl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    curl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.curl)
  return curl_;
}
inline ::std::string* Bid::release_curl() {
  clear_has_curl();
  if (curl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = curl_;
    curl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_curl(::std::string* curl) {
  if (curl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete curl_;
  }
  if (curl) {
    set_has_curl();
    curl_ = curl;
  } else {
    clear_has_curl();
    curl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.curl)
}

// required .AdType type = 17;
inline bool Bid::has_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Bid::set_has_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Bid::clear_has_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Bid::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::AdType Bid::type() const {
  // @@protoc_insertion_point(field_get:Bid.type)
  return static_cast< ::AdType >(type_);
}
inline void Bid::set_type(::AdType value) {
  assert(::AdType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Bid.type)
}

// repeated string extiurl = 18;
inline int Bid::extiurl_size() const {
  return extiurl_.size();
}
inline void Bid::clear_extiurl() {
  extiurl_.Clear();
}
inline const ::std::string& Bid::extiurl(int index) const {
  // @@protoc_insertion_point(field_get:Bid.extiurl)
  return extiurl_.Get(index);
}
inline ::std::string* Bid::mutable_extiurl(int index) {
  // @@protoc_insertion_point(field_mutable:Bid.extiurl)
  return extiurl_.Mutable(index);
}
inline void Bid::set_extiurl(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Bid.extiurl)
  extiurl_.Mutable(index)->assign(value);
}
inline void Bid::set_extiurl(int index, const char* value) {
  extiurl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.extiurl)
}
inline void Bid::set_extiurl(int index, const char* value, size_t size) {
  extiurl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.extiurl)
}
inline ::std::string* Bid::add_extiurl() {
  return extiurl_.Add();
}
inline void Bid::add_extiurl(const ::std::string& value) {
  extiurl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Bid.extiurl)
}
inline void Bid::add_extiurl(const char* value) {
  extiurl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Bid.extiurl)
}
inline void Bid::add_extiurl(const char* value, size_t size) {
  extiurl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Bid.extiurl)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Bid::extiurl() const {
  // @@protoc_insertion_point(field_list:Bid.extiurl)
  return extiurl_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Bid::mutable_extiurl() {
  // @@protoc_insertion_point(field_mutable_list:Bid.extiurl)
  return &extiurl_;
}

// optional string action = 19;
inline bool Bid::has_action() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Bid::set_has_action() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Bid::clear_has_action() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Bid::clear_action() {
  if (action_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_->clear();
  }
  clear_has_action();
}
inline const ::std::string& Bid::action() const {
  // @@protoc_insertion_point(field_get:Bid.action)
  return *action_;
}
inline void Bid::set_action(const ::std::string& value) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_ = new ::std::string;
  }
  action_->assign(value);
  // @@protoc_insertion_point(field_set:Bid.action)
}
inline void Bid::set_action(const char* value) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_ = new ::std::string;
  }
  action_->assign(value);
  // @@protoc_insertion_point(field_set_char:Bid.action)
}
inline void Bid::set_action(const char* value, size_t size) {
  set_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_ = new ::std::string;
  }
  action_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Bid.action)
}
inline ::std::string* Bid::mutable_action() {
  set_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    action_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Bid.action)
  return action_;
}
inline ::std::string* Bid::release_action() {
  clear_has_action();
  if (action_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = action_;
    action_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Bid::set_allocated_action(::std::string* action) {
  if (action_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete action_;
  }
  if (action) {
    set_has_action();
    action_ = action;
  } else {
    clear_has_action();
    action_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Bid.action)
}

// required .AdmType admtype = 20;
inline bool Bid::has_admtype() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Bid::set_has_admtype() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Bid::clear_has_admtype() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Bid::clear_admtype() {
  admtype_ = 1;
  clear_has_admtype();
}
inline ::AdmType Bid::admtype() const {
  // @@protoc_insertion_point(field_get:Bid.admtype)
  return static_cast< ::AdmType >(admtype_);
}
inline void Bid::set_admtype(::AdmType value) {
  assert(::AdmType_IsValid(value));
  set_has_admtype();
  admtype_ = value;
  // @@protoc_insertion_point(field_set:Bid.admtype)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ContentCategory> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ContentCategory>() {
  return ::ContentCategory_descriptor();
}
template <> struct is_proto_enum< ::AdType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdType>() {
  return ::AdType_descriptor();
}
template <> struct is_proto_enum< ::CreativeAttribute> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CreativeAttribute>() {
  return ::CreativeAttribute_descriptor();
}
template <> struct is_proto_enum< ::AdPosition> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdPosition>() {
  return ::AdPosition_descriptor();
}
template <> struct is_proto_enum< ::ScenarioType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ScenarioType>() {
  return ::ScenarioType_descriptor();
}
template <> struct is_proto_enum< ::ConnectionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ConnectionType>() {
  return ::ConnectionType_descriptor();
}
template <> struct is_proto_enum< ::LocationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LocationType>() {
  return ::LocationType_descriptor();
}
template <> struct is_proto_enum< ::DeviceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceType>() {
  return ::DeviceType_descriptor();
}
template <> struct is_proto_enum< ::AdmType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdmType>() {
  return ::AdmType_descriptor();
}
template <> struct is_proto_enum< ::NoBidReasonCodes> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NoBidReasonCodes>() {
  return ::NoBidReasonCodes_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_openrtb_2dv2_5f6_2eproto__INCLUDED
